#+LATEX_HEADER: \usepackage{amsthm}

\newtheoremstyle{defnstyle}{}{}{}{}{\scshape}{.}{\newline}{}

\theoremstyle{defnstyle}
\newtheorem{defn}{Definition}

* The Lectures

** Manifolds

Cryptically: a manifold is locally Euclidean. Let's take this as our
starting point rather than, as with some approaches, start with the
definition of a set, a topology, a topological manifold and finally a
differential manifold.

We need to relate a set to Euclidean space:

\begin{defn}[Co-ordinate Chart]
A co-ordinate chart on a set $X$ is a subset $U \subseteq X$
and a bijection

$$
\phi: U \longrightarrow \phi(U) \subseteq \mathbb{R}^n
$$

onto an open\footnote{Pre-requisites: what is a
topololgy, what is an open set, what is a continuous function} set $\phi(U)$ of $\mathbb{R}^n$.
\end{defn}

These bijections had better be compatible:

\begin{defn}[Atlas]
An atlas is a collection of co-ordinate charts $\{U_\alpha, \phi_\alpha\}_{\alpha \in I}$ such that

 1. $X$ is covered by the $\{U_\alpha, \phi_\alpha\}_{\alpha \in I}$.
 2. $\forall \alpha, \beta \in I$ , $\phi_\alpha(U_\alpha \cap U_\beta)$ is open in $\mathbb{R}^n$.
 3. The map $$\phi_\beta \circ \phi_\alpha^{-1}: \phi_\alpha(U_\alpha
    \cap U_\beta) \longrightarrow \phi_\beta(U_\alpha \cap U_\beta)$$
    is $C^\infty$ with $C^\infty$ inverse.
\end{defn}

 1. $X$ is covered by the $\{U_\alpha, \phi_\alpha\}_{\alpha \in I}$.
 2. $\forall \alpha, \beta \in I$ , $\phi_\alpha(U_\alpha \cap U_\beta)$ is open in $\mathbb{R}^n$.
 3. The map $$\phi_\beta \circ \phi_\alpha^{-1}: \phi_\alpha(U_\alpha
    \cap U_\beta) \longrightarrow \phi_\beta(U_\alpha \cap U_\beta)$$
    is $C^\infty$ with $C^\infty$ inverse.

* The Einstein Field Equations

$$
S_{EH} = \int {\mathcal{L}}_{EH}\sqrt{-g}\,\mathrm{d}^4 x
$$

To start with let's take ${\mathcal{L}}_{EH} = R$ where $R$ is the Ricci scalar.

* A General Relativity Bibliography

I started with cite:o1983semi which I still think is the best but
really quite hard going. It comes the closest to explaining what an
observer is. It stays away from overuse of indices. I think one only
needs to read chapters 1--6, 12 and 13.

For differential forms I read cite:darling_1994 but it doesn't cover
relativity.

These cite:tong-gr-lecture-notes are pretty good but I didn't really
follow his introductory chapter and skipped most of it. Maybe I could
now get more out of it. He doesn't say what an observer is but he does
use forms for some calculations instead of the raw curvature tensor to
make things easier.

https://tales.mbivert.com/on-heraeus-winter-school-tutorials/#tutorial-pdfs--missing-tutorial-videos

https://ncatlab.org/nlab/show/volume+form
volume form
https://math.stackexchange.com/questions/70938/natural-and-coordinate-free-definition-for-the-riemannian-volume-form

A treasure trove of explanations
https://virtualmath1.stanford.edu/~conrad/diffgeomPage/handouts/mapmaking.pdf
https://virtualmath1.stanford.edu/~conrad/diffgeomPage/handouts.html

** Phil's Bibliography

 1. cite:needham:2021DifferentialGeometry
 2. cite:needham:1998complex
 3. cite:needham:2023ComplexAnalysis

bibliography:DiffGeom.bib
bibliographystyle:unsrt

* A Proposal

I'd like to run a series of workshops (this might not be the right
name) in which everyone contributes to our collective understanding of
General Relativity.

I'd like the end goal to be: how do gravitational waves get generated
by binary stars for example and how did LIGO actually detect such
waves. I'd like to avoid the "tensor is as a tensor does approach" but
this may not be entirely possible.

There's a lot of stuff we'd have to understand on the way
(e.g. variational principles and differential geometry) and we might
not actually get there. But if you don't start something you never get
there.

Rather than spending a year creating notes that never see the light of
day, I am proposing we set off without the notes for gravitational
waves and create them as we go along.

I can certainly start the ball rolling with a talk on "Is a Straight
Lines Always the Shortest Distance: Some Steps Towards General
Relativity". The idea would be go through some concepts from
differential geometry and even write down the Einstein Equation whilst
noting down which concepts need to be explained in further workshops.

1. I am in and would like to prepare some material.
2. I'd like to participate but can't (yet) commit to preparing material.
3. This is too pretentious for words.

I assume I can somehow book a room in the University but maybe only
Dan or Barry can do that. I see no harm in advertising it within the
University and possibly more widely. Who knows? An expert on GR may
live locally and be keen to share their knowledge.

* Course Contents

** Prerequisites

Obviously multivariate calculus.

Linear algebra to some level.

** Topics

 1. What is a manifold
 2. Cotangent Space
 3. Tangent Space
 4. Vector Fields
 5. Differential Forms
 6. Tensors(?)
 7. Connections (via principal bundles? This may be taking things too far so probably just affine connections).
 8. Theorem Egregium (nothing to do with relativity but fun).
 9. Connections with torsion (Mercator).
 10. Geodesics aka straight lines.
 11. Metrics - compatatibility with the connection.
 12. Levi-Civita.
 13. Schwarzschild metric.
 14. Perihelion of Mercury
 15. Gravitational time dilation.
 16. Red shift (not sure I care about this).
 17. Stress Energy tensor - electromagnetism as the example - can we
     use a Nelkon example?
 18. Principle of Least Action.
 19. Einstein Equations via least action.
 20. Gravitational waves as a solition to the Einstein equations.
 21. Sources of gravitational waves: binary systems (stars, black holes).


* Some Random Links

This section is for my working notes.

https://www.quora.com/What-is-the-geometric-interpretation-of-the-concept-of-Connection-in-differential-geometry



https://www.intlpress.com/site/pub/files/_fulltext/journals/pamq/2010/0006/0002/PAMQ-2010-0006-0002-a008.pdf

** Lie Groups, Lie Algebras and the Exponential Map

https://www.cis.upenn.edu/~cis6100/cis61005sl8.pdf
cis61005sl8.pdf


** Schwarzschild Spacetime without Coordinates

Not sure why I have this as it seems to have a lot of indices

https://www.intlpress.com/site/pub/files/_fulltext/journals/pamq/2010/0006/0002/PAMQ-2010-0006-0002-a008.pdf

We discuss how to construct the full Schwarzschild (Kruskal- Szekeres)
spacetime in one swoop by using the bundle of orthonormal Lorentz
frames and the Einstein equation without the use of coordinates. We
never have to write down the Kruskal-Szekeres or an equivalent form of
the metric.

** Inkscape

Should I use this for the diagrams for principal bundles, connections?

** Other

A fibre bundle approach to U(1)
symmetries in physics
https://amslaurea.unibo.it/16776/1/tesi_mazzoni_finale_1.pdf

This would seem to be wrong but does derive the force from U(1)
https://math.sun.ac.za/bbartlett/assets/The%20geometry%20of%20force.pdf

https://www.damtp.cam.ac.uk/user/tong/em/el4.pdf
For the change of the EM 2 form under a boost

and his gauge theory
https://www.damtp.cam.ac.uk/user/tong/gaugetheory/gt.pdf

Differential
Geometry in
Physics Gabriel Lugo
https://libres.uncg.edu/ir/uncw/f/lugo2021-1.2.pdf

Differential Geometry and General Relativity: Volume 1 (Graduate Texts
in Physics) Hardcover – 29 Aug. 2023 by Canbin Liang (Author), Bin
Zhou (Author, Translator), Weizhen Jia (Translator)

Ernest
https://ernestyalumni.wordpress.com/category/qft/

https://github.com/ernestyalumni/Gravite/blob/master/LaTeXetpdfs/Gravity_Notes_grande.pdf

** Under transformations naively and otherwise

https://en.wikipedia.org/wiki/Lorentz_force

https://web.mit.edu/sahughes/www/8.022/lec11.pdf
https://web.mit.edu/sahughes/www/8.022/lec12.pdf

** Maybe Haskell Approach

https://groups.csail.mit.edu/mac/users/gjs/6946/calculus-indexed.pdf

** Other books

Gauge Fields, Knots and Gravity

https://proofwiki.org/wiki/Derivatives_of_Unit_Vectors_in_Polar_Coordinates#google_vignette

https://legacy.cs.indiana.edu/~hansona/papers/EguchiGilkeyHanson1980.pdf

** From GPT

No, the domain of the connection 1-form $\omega$ on the frame bundle $LM$ is not sections of the frame bundle, but rather the tangent vectors to the frame bundle $LM$. To clarify:

### 1. Connection 1-Form $\omega$

The connection 1-form $\omega$ is a $\mathfrak{gl}(n, \mathbb{R})$-valued 1-form on the frame bundle $LM$. Formally:
$$
\omega \in \Omega^1(LM, \mathfrak{gl}(n, \mathbb{R}))
$$
This means that $\omega$ assigns to each tangent vector in the frame bundle $LM$ a Lie algebra element in $\mathfrak{gl}(n, \mathbb{R})$.

### 2. Domain of $\omega$

The domain of $\omega$ is $TLM$, the tangent bundle of the frame bundle $LM$. For any point $p \in LM$ and tangent vector $v \in T_p LM$, $\omega(p)(v)$ is an element of $\mathfrak{gl}(n, \mathbb{R})$.

### 3. Sections of the Frame Bundle

A section $\sigma: U \to LM$ of the frame bundle is a map from an open subset $U \subseteq M$ to the frame bundle $LM$. The section $\sigma$ provides a way to pull back the connection 1-form $\omega$ from the frame bundle $LM$ to the base manifold $U \subseteq M$.

### 4. Pullback of $\omega$ via $\sigma$

When you have a local section $\sigma: U \to LM$, you can pull back the connection 1-form $\omega$ to $U$. This pullback, denoted by $\sigma^*\omega$, is a $\mathfrak{gl}(n, \mathbb{R})$-valued 1-form on $U$:
$$
\sigma^*\omega \in \Omega^1(U, \mathfrak{gl}(n, \mathbb{R}))
$$
The pullback is defined by:
$$
(\sigma^*\omega)(v) = \omega(\sigma_*(v))
$$
for any tangent vector $v \in TU$. Here, $\sigma_*: TU \to TLM$ is the pushforward of the section $\sigma$, which maps a tangent vector $v \in T_m U$ to a tangent vector $\sigma_*(v) \in T_{\sigma(m)} LM$.

### Summary

- The connection 1-form $\omega$ is defined on the tangent bundle of the frame bundle $TLM$, not on sections of the frame bundle.
- Sections of the frame bundle can be used to pull back $\omega$ to the base manifold, resulting in a $\mathfrak{gl}(n, \mathbb{R})$-valued 1-form on the base manifold.

So, in summary, while $\omega$ itself is not applied directly to sections, sections are used to pull back $\omega$ to the base manifold. The primary domain of $\omega$ is indeed the tangent bundle of the frame bundle $TLM$.

*** Part II

No, $\Gamma(U)$ and $\Omega^1(U)$ are not the same.

### $\Gamma(U)$

- $\Gamma(U)$ typically denotes the space of sections of a fiber bundle over the open subset $U$ of a manifold $M$.
- If we are talking about the tangent bundle $TM$, $\Gamma(U)$ represents the space of vector fields on $U$, which are smooth sections of the tangent bundle restricted to $U$.

Formally:
$$ \Gamma(U, TM) = \{ X: U \to TM \mid X \text{ is a smooth section of } TM \} $$
This means that $\Gamma(U, TM)$ consists of all smooth vector fields defined on the open subset $U$.


### $\Omega^1(U)$

- $\Omega^1(U)$ denotes the space of 1-forms on the open subset $U$.
- A 1-form is a smooth section of the cotangent bundle $T^*M$.

Formally:
$$ \Omega^1(U) = \Gamma(U, T^*M) = \{ \alpha: U \to T^*M \mid \alpha \text{ is a smooth section of } T^*M \} $$
This means that $\Omega^1(U)$ consists of all smooth 1-forms defined on the open subset $U$.

### Distinction

- $\Gamma(U, TM)$ is the space of vector fields, which are sections of the tangent bundle.
- $\Omega^1(U)$ is the space of 1-forms, which are sections of the cotangent bundle.

They are different objects because one deals with vector fields (tangent vectors) and the other deals with differential 1-forms (covectors).

### Summary

In summary, $\Gamma(U)$ and $\Omega^1(U)$ refer to different spaces:
- $\Gamma(U, TM)$ or simply $\Gamma(U)$ is the space of smooth vector fields on $U$.
- $\Omega^1(U)$ is the space of smooth 1-forms on $U$.

These spaces are related but distinct, as vector fields and 1-forms are dual to each other.

*** Part III

A $\mathfrak{gl}(n, \mathbb{R})$-valued 1-form $\omega \in \Omega^1(U, \mathfrak{gl}(n, \mathbb{R})$ takes a vector field $X \in \Gamma(U, TM)$ and returns a section of the Lie algebra bundle $\mathfrak{gl}(n, \mathbb{R})$ over $U$. 

In other words, for a vector field $X \in \Gamma(U)$, $\omega(X)$ is a smooth map from $U$ to $\mathfrak{gl}(n, \mathbb{R})$. More concretely, $\omega$ evaluated on the vector field $X$ at each point $p \in U$ gives an element of the Lie algebra $\mathfrak{gl}(n, \mathbb{R})$.

### Formally:

1. **Connection 1-Form**:
   $$
   \omega \in \Omega^1(U, \mathfrak{gl}(n, \mathbb{R})) 
   $$
   This means that $\omega$ is a $\mathfrak{gl}(n, \mathbb{R})$-valued 1-form on $U$.

2. **Vector Field**:
   $$
   X \in \Gamma(U, TM)
   $$
   This means that $X$ is a smooth section of the tangent bundle $TM$ over $U$, or equivalently, a vector field on $U$.

3. **Evaluation**:
   $$
   \omega(X) \in \Gamma(U, \mathfrak{gl}(n, \mathbb{R}))
   $$
   This means that $\omega(X)$ is a smooth map from $U$ to $\mathfrak{gl}(n, \mathbb{R})$. For each point $p \in U$, $\omega(X)_p \in \mathfrak{gl}(n, \mathbb{R})$.

### Concretely:

- At each point $p \in U$, the vector field $X$ gives a tangent vector $X_p \in T_p U$.
- The 1-form $\omega$, when applied to the vector field $X$, produces a map:
  $$
  p \mapsto \omega_p(X_p)
  $$
- Here, $\omega_p$ is a linear map from $T_p U$ to $\mathfrak{gl}(n, \mathbb{R})$, and $X_p$ is the tangent vector at $p$.

Therefore, $\omega(X)$ is a section of the bundle whose fibers are the Lie algebra $\mathfrak{gl}(n, \mathbb{R})$. In practical terms, at each point $p$ in the domain $U$, $\omega(X)$ assigns an element of $\mathfrak{gl}(n, \mathbb{R})$.

### Summary:

For a $\mathfrak{gl}(n, \mathbb{R})$-valued 1-form $\omega$ and a vector field $X$,
- $\omega(X)$ is a section of the bundle with fiber $\mathfrak{gl}(n, \mathbb{R})$.
- It returns a smooth map from the open subset $U$ to $\mathfrak{gl}(n, \mathbb{R})$, associating to each point $p \in U$ an element $\omega_p(X_p) \in \mathfrak{gl}(n, \mathbb{R})$.

*** For my question

Let's clarify the nature of \(\omega\) in this context.

### 1. The Connection 1-Form \(\omega\)

The connection 1-form \(\omega\) is initially defined on the frame bundle \(LM\). It is a \(\mathfrak{gl}(n, \mathbb{R})\)-valued 1-form, meaning:
\[
\omega \in \Omega^1(LM, \mathfrak{gl}(n, \mathbb{R}))
\]
This form assigns to each tangent vector in \(LM\) an element of the Lie algebra \(\mathfrak{gl}(n, \mathbb{R})\).

### 2. Pulling Back \(\omega\)

To work with \(\omega\) in the context of the base manifold \(M\), we use a local section \(\sigma: U \to LM\). The pullback of \(\omega\) via \(\sigma\) gives a \(\mathfrak{gl}(n, \mathbb{R})\)-valued 1-form on \(U\):
\[
\sigma^*\omega \in \Omega^1(U, \mathfrak{gl}(n, \mathbb{R}))
\]
This pullback is defined for any vector field \(X \in \Gamma(U, TM)\) by:
\[
(\sigma^*\omega)(X) = \omega(\sigma_*(X))
\]

### 3. The Nature of \(\sigma^*\omega\)

The pullback \(\sigma^*\omega\) is a \(\mathfrak{gl}(n, \mathbb{R})\)-valued 1-form on \(U\). This means \(\sigma^*\omega\) is a section of the cotangent bundle of \(U\) with values in \(\mathfrak{gl}(n, \mathbb{R})\):
\[
\sigma^*\omega \in \Omega^1(U) \otimes \mathfrak{gl}(n, \mathbb{R})
\]
Or equivalently:
\[
\sigma^*\omega \in \Gamma(U, T^*U \otimes \mathfrak{gl}(n, \mathbb{R}))
\]

### 4. Evaluating \(\sigma^*\omega\) on a Vector Field

When \(\sigma^*\omega\) is evaluated on a vector field \(X \in \Gamma(U, TM)\), it produces a \(\mathfrak{gl}(n, \mathbb{R})\)-valued function on \(U\). Explicitly:
\[
(\sigma^*\omega)(X): U \to \mathfrak{gl}(n, \mathbb{R})
\]
At each point \(p \in U\), \((\sigma^*\omega)(X)_p\) is an element of \(\mathfrak{gl}(n, \mathbb{R})\).

### Summary

- \(\omega\) is initially a \(\mathfrak{gl}(n, \mathbb{R})\)-valued 1-form on the frame bundle \(LM\).
- The pullback \(\sigma^*\omega\) via a local section \(\sigma\) is a \(\mathfrak{gl}(n, \mathbb{R})\)-valued 1-form on \(U\), meaning it is a section of the cotangent bundle on \(U\) with values in \(\mathfrak{gl}(n, \mathbb{R})\).
- When \(\sigma^*\omega\) is evaluated on a vector field \(X \in \Gamma(U, TM)\), it yields a \(\mathfrak{gl}(n, \mathbb{R})\)-valued function on \(U\).

So, to directly answer your question: Yes, the pullback \(\sigma^*\omega\) is a section of the cotangent bundle on \(U\) with values in the Lie algebra \(\mathfrak{gl}(n, \mathbb{R})\).

*** Working

$\left(\Phi_g\right)_*\left(H_q P\right)=H_{\Phi_g(q)} P \quad \forall g \in G, q \in P$

& =X_{p \triangleleft g}^{\left(\operatorname{Ad}_{g^{-1}}\right)_* A}(f),

& =\omega_{p \triangleleft g}\left(X_{p \triangleleft g}^{\left(\operatorname{Ad}_{g-1}\right)_* A}\right) \\

** Not needed from notebook

### Principal $GL(n, \mathbb{R})$-Bundle Structure

To form $LpM$ into a principal $GL(n, \mathbb{R})$-bundle over $M$, where $n = \dim M$:

1. **Total Space**: $LpM$ is the space of ordered bases of $T_pM$ at each point $p \in M$.

2. **Projection Map**: $\pi: LpM \to M$ is defined by $\pi(e_1, e_2, \ldots, e_n) = p$, where $(e_1, e_2, \ldots, e_n)$ is a basis for $T_pM$.

3. **Action of $GL(n, \mathbb{R})$**: The action of $g \in GL(n, \mathbb{R})$ on a basis $(e_1, e_2, \ldots, e_n)$ is given by:
   $$
   e_i' = \sum_{j=1}^n g_{ij} e_j
   $$
   for $i = 1, 2, \ldots, n$, where $(e_1', e_2', \ldots, e_n')$ is the new basis after applying $g$.

   $$g^a_1 e_a$$

5. **Principal Bundle Properties**:
   - The action of $GL(n, \mathbb{R})$ is free and transitive on the fibers.
   - The projection map and action are smooth.

Hence, $LpM$ with this projection and action forms a principal $GL(n, \mathbb{R})$-bundle over $M$.

* Log for [2024-08-18 Sun 17:39]

S2 = Manifold(2, 'S^2', latex_name = r'S^2', start_index = 1)
U = S2.open_subset('U')
polar.<th,ph> = U.chart(r'th:(0,pi):\theta ph:(0,2*pi):\phi')

LM = Manifold(6, 'FrameBundle', latex_name=r'LM', start_index=1)
V = LM.open_subset('V')
frame_chart.<th,ph,v11, v12, v21, v22> = V.chart()

Is it possible to define a Lie algebra-valued 1-form on a manifold?
Ideally I would like to define such a form on a principal bundle. I
could define real-valued 1-forms and use some sort of indexing
convention but then I end up with a débauches d'indices as Cartan
might have said.

My objective is to show in Sage Manifolds how to lift a connection
1-form on the base manifold to a connection 1-form on the principal
bundle. In my example, I am using the frame bundle over the open
subset $U = (0,\pi) \times (0, 2\pi)$ of the sphere. Thus the Lie
group is GL(2) and the Lie algebra is any 2 x 2 matrix.

* Log for [2024-08-27 Tue 14:54]

https://webusers.imj-prg.fr/~elisha.falbel/poly.pdf (this
https://adebray.github.io/lecture_notes/m392c_RG_notes.pdf may be of
interest)

\begin{aligned}
\left(R_g^* \theta\right)_x\left(B\right) & = \theta_{xg}\left(\left.\left(R_g\right)_*\right|_e\left(B\right)\right) \\
& =\left(L_{x g}\right)_*\left(\left.\frac{\mathrm{d}}{\mathrm{d} t}\right|_{t=0} \left(x e^{t X^B_x} g\right)\right) \\
& =\left.\frac{\mathrm{d}}{\mathrm{d} t}\right|_{t=0}(x g)^{-1}\left(x e^{t X^B_x} g\right) \\
& =\left.\frac{\mathrm{d}}{\mathrm{d} t}\right|_{t=0} g^{-1} e^{t X^B_x} g \\
& =\mathrm{Ad}_{g-1} X^B_x .
\end{aligned}

https://www.columbia.edu/~ask2262/MathSeniorThesis2023/KudinoorMathSeniorThesisMarch2023.pdf

Also demystifying gauge symmetry

https://diposit.ub.edu/dspace/bitstream/2445/192109/1/tfg_de_muniategui_climente_martin.pdf

https://terrytao.wordpress.com/2008/09/27/what-is-a-gauge/

Search term "electromagnetism connection gauge principal bundle maxwell"

Fundamental Vector Field U(1)

import Mathlib.Analysis.Manifold.SmoothMap
import Mathlib.Analysis.Manifold.SmoothStructure

-- Open the locale for manifolds
open_locale manifold

-- Define the manifolds and smooth maps
variables {M N P : Type*}
  [smooth_manifold_with_corners I (model_prod 𝓘(ℝ, ℝ) ℝ) M]
  [smooth_manifold_with_corners I (model_prod 𝓘(ℝ, ℝ) ℝ) N]
  [smooth_manifold_with_corners I (model_prod 𝓘(ℝ, ℝ) ℝ) P]

variables (f : M → N) (g : N → P)

-- Assume f and g are smooth maps
variables [smooth_map I (model_prod 𝓘(ℝ, ℝ) ℝ) I (model_prod 𝓘(ℝ, ℝ) ℝ) f]
          [smooth_map I (model_prod 𝓘(ℝ, ℝ) ℝ) I (model_prod 𝓘(ℝ, ℝ) ℝ) g]

-- Prove that the composition g ∘ f is smooth
lemma smooth_map_comp (hf : smooth_map I (model_prod 𝓘(ℝ, ℝ) ℝ) I (model_prod 𝓘(ℝ, ℝ) ℝ) f)
  (hg : smooth_map I (model_prod 𝓘(ℝ, ℝ) ℝ) I (model_prod 𝓘(ℝ, ℝ) ℝ) g) :
  smooth_map I (model_prod 𝓘(ℝ, ℝ) ℝ) I (model_prod 𝓘(ℝ, ℝ) ℝ) (g ∘ f) :=
begin
  -- Use the composition theorem
  exact hg.comp hf,
end




-- Define the manifolds and smooth maps
variables {M : Type*}

* Log for [2024-09-16 Mon 12:36]

-- import Mathlib.Geometry.Manifold.VectorBundle.SmoothSection
-- import Mathlib.Geometry.Manifold.VectorBundle.Hom
-- import Mathlib.Geometry.Manifold.VectorBundle.Pullback
-- import Mathlib.Geometry.Manifold.ContMDiffMFDeriv
-- import Mathlib.Geometry.Manifold.Instances.Sphere

-- import Mathlib.Analysis.NormedSpace.Connected
-- import Mathlib.LinearAlgebra.TensorProduct
-- import Mathlib.Analysis.NormedSpace.Dual



variable {𝕜 : Type*} [NontriviallyNormedField 𝕜]

https://www.reddit.com/r/emacs/comments/sgcwuq/usepackage_unrecognized_keyword_straight/

-- import Mathlib.Geometry.Manifold.ChartedSpace
-- import Mathlib.geometry.manifold.SmoothManifoldWithCorners
import Mathlib

-- variable {𝕜 : Type*} [NontriviallyNormedField 𝕜]

-- variable
--   -- declare a smooth manifold `M` over the pair `(E, H)`.
--   {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]
--   (I : ModelWithCorners 𝕜 E H) {M : Type*} [TopologicalSpace M] [ChartedSpace H M]
--   [SmoothManifoldWithCorners I M]

import Mathlib

variable {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M] [SmoothManifoldWithCorners (𝓡 1) M]

-- import Mathlib.Geometry.Manifold.ChartedSpace
-- import Mathlib.geometry.manifold.SmoothManifoldWithCorners
import Mathlib

variable {𝕜 : Type*} [NontriviallyNormedField 𝕜]

variable
  {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]
  (I : ModelWithCorners 𝕜 E H) {M : Type*} [TopologicalSpace M] [ChartedSpace H M]
  [SmoothManifoldWithCorners I M]

variable
  {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (I : ModelWithCorners ℝ E ℝ) {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M]
  [SmoothManifoldWithCorners I M]
  
open Manifold

variable
  (n : ℕ) {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M]
  [SmoothManifoldWithCorners (𝓡 n) M]
  
variable
  {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (I : ModelWithCorners ℝ E ℝ) {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M]
  [SmoothManifoldWithCorners (𝓡 1) M]
  

-- variable {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M] [SmoothManifoldWithCorners (𝓡 1) M]

* Log for [2024-09-17 Tue 08:08]

variable
  (n : ℕ) {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M]
  [SmoothManifoldWithCorners (𝓡 n) M]
  
variable
  {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (I : ModelWithCorners ℝ E ℝ) {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M]
  [SmoothManifoldWithCorners (𝓡 1) M]

** Sort of working

variable {𝕜 : Type*} [NontriviallyNormedField 𝕜]

variable
  {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]
  (I : ModelWithCorners 𝕜 E H) {M : Type*} [TopologicalSpace M] [ChartedSpace H M]
  [SmoothManifoldWithCorners I M]

variable
  {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]
  (I : ModelWithCorners ℝ E ℝ) {M : Type*} [TopologicalSpace M] [ChartedSpace ℝ M]
  [SmoothManifoldWithCorners I M]
  
open Manifold

#check (𝓡 1)
#check SmoothManifoldWithCorners (𝓡 1)

import Mathlib.Topology.Basic

-- Define two topological spaces
variables {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y]

-- Define a map between the spaces
variable (f : X → Y)

-- Define the continuity of f
theorem continuous_map : Continuous f :=
begin
  -- The proof goes here, depending on the specific map and topologies.
  -- In this case, we'll assume `f` is continuous.
  exact continuous_id,
end

** Question

import Mathlib

open Manifold

variable
  (m : ℕ) {M : Type*}
   [TopologicalSpace M]
   [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
   [SmoothManifoldWithCorners (𝓡 m) M]

variable
  (n : ℕ) {N : Type*}
   [TopologicalSpace N]
   [ChartedSpace (EuclideanSpace ℝ (Fin n)) N]
   [SmoothManifoldWithCorners (𝓡 n) N]

variable
  (p : ℕ) {P : Type*}
   [TopologicalSpace P]
   [ChartedSpace (EuclideanSpace ℝ (Fin p)) P]
   [SmoothManifoldWithCorners (𝓡 p) P]

variable {X Y Z : Type} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]

theorem compositionOfContinuousFunctions {f : X → Y} {g : Y -> Z} (hf : Continuous f) (hg : Continuous g) (IsOpen s) :=
  IsOpen s
  IsOpen (g ⁻¹' s)
  IsOpen (f ⁻¹' (g ⁻¹' s))


-- #check Continuous

** My Goal

I started off some time ago thinking I could a) produce some lectures
on General Relativity without a débauches d'indices (as Cartan would
say) and maybe as part of this do a simulation of two black holes
coalescing to produce a gravitational wave. Clearly way too ambitious!

Also some time ago I contributed a small example of a connection with
torsion to the computer algebra package for General Relativity, Sage
Manifolds. This package is great as it saves a lot of work
e.g. calculating the components of a Rank 4 tensor in 4 dimensions and
ensures that you don't make (some) mistakes. There used to be an
example of the Faraday tensor but this suffered from bitrot so I
offered to write a small example showing how to derive and maybe use
the Faraday tensor.

In a way Sage Manifolds is great but it is basically Python and gives
very opaque error messages (for me at any rate). After I had done much
reading, I realised that I could express electromagnetism as a Gauge
Theory (a connection on a principal bundle over a base manifold). But
Sage Manifolds does not support principal bundle (at least as far as I
can tell). So I started off defining a principal bundle etc in Sage but the
whole experience became very frustrating and then I saw a lot of work
had been done in Lean on maths and differential geometry.

So here I am several rabbit holes within rabbit holes but nonetheless
having a lot of fun.

** More crud

import Mathlib

open Manifold

variable
  (m : ℕ) {M : Type*}
   [TopologicalSpace M]
   [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
   [SmoothManifoldWithCorners (𝓡 m) M]

variable
  (n : ℕ) {N : Type*}
   [TopologicalSpace N]
   [ChartedSpace (EuclideanSpace ℝ (Fin n)) N]
   [SmoothManifoldWithCorners (𝓡 n) N]

-- example {f : M → N} (hf : sorry f) :
    sorry := by sorry
    
-- #check SmoothMap


variable {X Y Z : Type} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]

-- example {f : X → Y} : Continuous f ↔ ∀ s, IsOpen s → IsOpen (f ⁻¹' s) :=
--   continuous_def
  
-- #check continuous_def

-- Define two topological spaces
-- variable {X Y Z : Type} [MetricSpace X] [MetricSpace Y] [MetricSpace Z]

variable (S : Set Z)

theorem compositionOfContinuousFunctions {f : X → Y} {g : Y -> Z} (hf : Continuous f) (hg : Continuous g) (hS : IsOpen S) :
    Continuous (g ∘ f) := by
    have hg_preimage : IsOpen (g ⁻¹' S) := hg.isOpen_preimage S hS
    have fg_preimage : IsOpen (f⁻¹' (g⁻¹' S)) := hf.isOpen_preimage (g⁻¹' S) hg_preimage
    sorry
  

-- example {f : X → Y} {g : Y -> Z} (hf : Continuous f) (hg : Continuous g) (hS : IsOpen S) :
--   sorry

theorem compositionOfContinuousFunctions {f : X → Y} {g : Y -> Z} (hf : Continuous f) (hg : Continuous g) (IsOpen s) :=
  IsOpen s
  IsOpen (g ⁻¹' s)
  IsOpen (f ⁻¹' (g ⁻¹' s))
  Continuous (g ∘ f)


-- #check Continuous

-- variable {f : M -> N} [SmoothMap M N f]

** Response

Well de gustibus but no doubt in a few months time of working in Lean
such a proof will be lucidity itself. I am impressed by your
undergraduates.

Here's my "squinting":

So =rw [continuous_def]= rewrites =Continuous= as given by the definition

#+BEGIN_SRC lean4
Continuous f ↔ ∀ s, IsOpen s → IsOpen (f ⁻¹' s)
#+END_SRC

By saying =intro s hs=, Lean somehow knows that $s$ is meant to be an
open set in the codomain of $g \circ f$, which is $Z$ (and =hs= is a
proof of this?).

=g ⁻¹' U= is open by the proof(?) =hg= that =g= is continuous to the
open set =s= (with a proof of openness = hs=).

#+BEGIN_SRC lean4
IsOpen (g ⁻¹' s) := hg s hs
#+END_SRC

We next show that =f ⁻¹' (g ⁻¹' s)= is open using the proof(?) =hf= on
the open set =(g ⁻¹' s)= (which is open by =hg_preimage=).

And we are done.

* Log for [2024-09-19 Thu 09:52]

le_top.{u} {α : Type u} [LE α] [OrderTop α] {a : α} : a ≤ ⊤

example [TopologicalSpace X] [TopologicalSpace Y] {x₀ : X} (f : X → X → Y)
    (hf : ContinuousAt (Function.uncurry f) (x₀, x₀)) :
    ContinuousAt (fun x ↦ f x x) x₀ :=
  hf.comp_of_eq (continuousAt_id.prod continuousAt_id) rfl -- works

theorem ContinuousAt.comp_of_eq {g : Y → Z} (hg : ContinuousAt g y)
    (hf : ContinuousAt f x) (hy : f x = y) : ContinuousAt (g ∘ f) x := by subst hy; exact hg.comp hf

theorem Bar {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]
  {f : X → Y} {g : Y → Z} {x : X} {y : Y}
  (hf : ContinuousAt f x) (hg : ContinuousAt g y) (hy : f x = y) : ContinuousAt (g ∘ f) x := by subst hy; exact hg.comp hf

nonrec theorem Baz {g : Y → Z} (hg : ContinuousAt g (f x))
    (hf : ContinuousAt f x) : ContinuousAt (g ∘ f) x :=
  hg.comp hf

* Log for [2024-09-21 Sat 18:09]

def getChartAt (p : M) : LocalHomeomorph M (EuclideanSpace ℝ m) :=
  chartAt (EuclideanSpace ℝ m) p

* Log for [2024-09-22 Sun 08:50]

There is a variety of constructions of Brownian motion in the literature. The approach we have
followed goes back to one of the great pioneers of Brownian motion, the French mathematician
Paul Lévy. Lévy’s construction has the advantage that continuity properties of
Brownian motion can be obtained from the construction. An alternative is to first show that a
Markov process with the correct transition probabilities can be constructed, and then to use an
abstract criterion, like Kolmogorov’s criterion for the existence of a continuous version of the
process.

`/Users/dom/.elan/toolchains/leanprover--lean4---v4.12.0-rc1/bin/lake setup-file /Users/dom/Dropbox/Tidy/DifferentialGeometry/mathematics_in_lean/MIL/Test2.lean Init Mathlib LLMlean` failed:

stderr:
⚠ [5118/5122] Built LLMlean.API
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:283:46: unused variable `state`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:287:47: unused variable `state`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:367:20: `Lean.HashSet` has been deprecated, use `Std.HashSet` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:367:38: `Lean.HashSet.empty` has been deprecated, use `Std.HashSet.empty` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:385:20: `Lean.HashSet` has been deprecated, use `Std.HashSet` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:385:38: `Lean.HashSet.empty` has been deprecated, use `Std.HashSet.empty` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:403:20: `Lean.HashSet` has been deprecated, use `Std.HashSet` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:403:38: `Lean.HashSet.empty` has been deprecated, use `Std.HashSet.empty` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:440:20: `Lean.HashSet` has been deprecated, use `Std.HashSet` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:440:38: `Lean.HashSet.empty` has been deprecated, use `Std.HashSet.empty` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:459:20: `Lean.HashSet` has been deprecated, use `Std.HashSet` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:459:38: `Lean.HashSet.empty` has been deprecated, use `Std.HashSet.empty` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:477:20: `Lean.HashSet` has been deprecated, use `Std.HashSet` instead
warning: ././.lake/packages/llmlean/././LLMlean/API.lean:477:38: `Lean.HashSet.empty` has been deprecated, use `Std.HashSet.empty` instead
✖ [5119/5122] Building LLMlean.LLMstep
trace: .> LEAN_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/LeanSearchClient/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/packages/llmlean/.lake/build/lib:././.lake/build/lib DYLD_LIBRARY_PATH=././.lake/packages/batteries/.lake/build/lib:././.lake/packages/Qq/.lake/build/lib:././.lake/packages/aesop/.lake/build/lib:././.lake/packages/proofwidgets/.lake/build/lib:././.lake/packages/Cli/.lake/build/lib:././.lake/packages/importGraph/.lake/build/lib:././.lake/packages/mathlib/.lake/build/lib:././.lake/build/lib:/Users/dom/.elan/toolchains/leanprover--lean4---v4.12.0-rc1/lib/lean:/Users/dom/.elan/toolchains/leanprover--lean4---v4.12.0-rc1/lib /Users/dom/.elan/toolchains/leanprover--lean4---v4.12.0-rc1/bin/lean ././.lake/packages/llmlean/././LLMlean/LLMstep.lean -R ././.lake/packages/llmlean/./. -o ././.lake/packages/llmlean/.lake/build/lib/LLMlean/LLMstep.olean -i ././.lake/packages/llmlean/.lake/build/lib/LLMlean/LLMstep.ilean -c ././.lake/packages/llmlean/.lake/build/ir/LLMlean/LLMstep.c --json
error: ././.lake/packages/llmlean/././LLMlean/LLMstep.lean:25:2: unknown attribute [widget]
error: ././.lake/packages/llmlean/././LLMlean/LLMstep.lean:134:6: unknown identifier 'Widget.saveWidgetInfo'
error: ././.lake/packages/llmlean/././LLMlean/LLMstep.lean:122:6: invalid {...} notation, expected type is not known
error: Lean exited with code 1
Some required builds logged failures:
- LLMlean.LLMstep
error: build failed

def smooth_comp_f (φ : local_homeomorph N (euclidean_space ℝ (fin n))) 
                  (ψ : local_homeomorph M (euclidean_space ℝ (fin m))) :
                  Prop :=
  smooth ((𝓡 m).prod (𝓡 n)) (euclidean_space ℝ (fin n)) (λ x, φ.to_fun (f (ψ.inv_fun x)))

  def smooth_comp_g (φ : ((chartAt (EuclideanSpace ℝ (Fin n)) q).toFun))
                  (ψ : ((chartAt (EuclideanSpace ℝ (Fin m)) p).invFun)) :
                  Prop :=
  sorry -- Smooth ((𝓡 m).prod (𝓡 n)) (EuclideanSpace ℝ (Fin n)) (λ x => φ.to_fun (f (ψ.inv_fun x)))

  type expected, got
  (↑(chartAt (EuclideanSpace ℝ (Fin n)) q).toPartialEquiv : N → EuclideanSpace ℝ (Fin n))

  def smooth_comp_g (φ : PartialHomeomorph P (EuclideanSpace ℝ (Fin p))) 
                  (ψ : PartialHomeomorph N (EuclideanSpace ℝ (Fin n))) :
                  Prop :=
  Smooth (𝓡 n) (𝓡 p) (φ.toFun ∘ g ∘ ψ.invFun)

  
theorem smooth_composition_of_smooth_maps' {f : M → N} {g : N → P} (hf : smooth_map f) (hg : smooth_map g) :
    smooht_map (g ∘ f) := by
  sorry

* Log for [2024-09-24 Tue 08:03]

-- theorem smooth_composition_of_smooth_maps {f : M → N} {g : N → P}
--   (hf : smooth_map m n f) (hg : smooth_map n p g) : smooth_map m p (g ∘ f) :=
--   fun x =>
--     let φ := chartAt (EuclideanSpace ℝ (Fin p)) (g (f x))
--     let ψ := chartAt (EuclideanSpace ℝ (Fin n)) (f x)
--     let χ := chartAt (EuclideanSpace ℝ (Fin m)) x
--     -- First, show that ψ ∘ f ∘ χ⁻¹ is smooth
--     have h1 : Smooth (𝓡 m) (𝓡 n) (ψ.toFun ∘ f ∘ χ.invFun) := hf x
--     -- Second, show that φ ∘ g ∘ ψ⁻¹ is smooth
--     have h2 : Smooth (𝓡 n) (𝓡 p) (φ.toFun ∘ g ∘ ψ.invFun) := hg (f x)
--     -- Now, use the smoothness of the compositions
--     suffices Smooth (𝓡 m) (𝓡 p) (φ.toFun ∘ g ∘ f ∘ χ.invFun) by
--       exact this
--     -- Combine them: φ ∘ g ∘ ψ⁻¹ ∘ ψ ∘ f ∘ χ⁻¹
--     show Smooth (𝓡 m) (𝓡 p) (φ.toFun ∘ g ∘ ψ.invFun ∘ ψ.toFun ∘ f ∘ χ.invFun) from
--           Smooth.comp h2 h1


-- Theorem: composition of smooth maps is smooth
-- theorem smooth_composition_of_smooth_maps {f : M → N} {g : N → P}
--   (hf : smooth_map m n f) (hg : smooth_map n p g) : smooth_map m p (g ∘ f) :=
--   fun x =>
--   let φ := chartAt (EuclideanSpace ℝ (Fin p)) (g (f x))
--   let ψ := chartAt (EuclideanSpace ℝ (Fin n)) (f x)
--   let χ := chartAt (EuclideanSpace ℝ (Fin m)) x
--   suffices Smooth (𝓡 m) (𝓡 p) (φ.toFun ∘ g ∘ f ∘ χ.invFun) by
--       exact this
--   Smooth.comp (hg (f x)) (hf x)
--   sorry

import Mathlib

open Manifold

variable
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]

variable
  (n : ℕ) {N : Type*}
  [TopologicalSpace N]
  [ChartedSpace (EuclideanSpace ℝ (Fin n)) N]
  [SmoothManifoldWithCorners (𝓡 n) N]

variable
  (p : ℕ) {P : Type*}
  [TopologicalSpace P]
  [ChartedSpace (EuclideanSpace ℝ (Fin p)) P]
  [SmoothManifoldWithCorners (𝓡 p) P]

-- Definition of a smooth map using charts of the manifolds
def smooth_map (f : M → N) : Prop :=
  ∀ (x : M), Smooth (𝓡 m) (𝓡 n)
    ((chartAt (EuclideanSpace ℝ (Fin n)) (f x)).toFun ∘ f ∘ (chartAt (EuclideanSpace ℝ (Fin m)) x).invFun)

-- Theorem: Composition of smooth maps is smooth
theorem smooth_composition_of_smooth_maps {f : M → N} {g : N → P}
  (hf : smooth_map m n f) (hg : smooth_map n p g) : smooth_map m p (g ∘ f) :=
  fun x =>
    let φ := chartAt (EuclideanSpace ℝ (Fin p)) (g (f x))
    let ψ := chartAt (EuclideanSpace ℝ (Fin n)) (f x)
    let χ := chartAt (EuclideanSpace ℝ (Fin m)) x
    -- Show ψ ∘ f ∘ χ⁻¹ is smooth
    have h1 : Smooth (𝓡 m) (𝓡 n) (ψ.toFun ∘ f ∘ χ.invFun) := hf x
    -- Show φ ∘ g ∘ ψ⁻¹ is smooth
    have h2 : Smooth (𝓡 n) (𝓡 p) (φ.toFun ∘ g ∘ ψ.invFun) := hg (f x)
    -- Now, combine these to show φ ∘ g ∘ f ∘ χ⁻¹ is smooth
    have : (φ.toFun ∘ g ∘ ψ.invFun ∘ ψ.toFun ∘ f ∘ χ.invFun) =
           (φ.toFun ∘ g ∘ f ∘ χ.invFun) := by simp [Function.comp]
    sorry


- Theorem: Composition of smooth maps is smooth
theorem smooth_composition_of_smooth_maps {f : M → N} {g : N → P}
  (hf : smooth_map m n f) (hg : smooth_map n p g) : smooth_map m p (g ∘ f) :=
  fun x =>
    let φ := chartAt (EuclideanSpace ℝ (Fin p)) (g (f x))
    let ψ := chartAt (EuclideanSpace ℝ (Fin n)) (f x)
    let χ := chartAt (EuclideanSpace ℝ (Fin m)) x
    -- Show ψ ∘ f ∘ χ⁻¹ is smooth
    have h1 : Smooth (𝓡 m) (𝓡 n) (ψ.toFun ∘ f ∘ χ.invFun) := hf x
    -- Show φ ∘ g ∘ ψ⁻¹ is smooth
    have h2 : Smooth (𝓡 n) (𝓡 p) (φ.toFun ∘ g ∘ ψ.invFun) := hg (f x)

    -- Show that ψ.invFun ∘ ψ.toFun is the identity on its source
    have h_eq : ∀ y ∈ ψ.source, ψ.invFun (ψ.toFun y) = y := 
      by intro y hy; exact PartialHomeomorph.left_inv ψ hy

    have h_combined : ∀ z, φ.toFun (g (ψ.invFun (ψ.toFun (f (χ.invFun z))))) = φ.toFun (g (f (χ.invFun z))) :=
      by apply h_eq
    
    sorry

f (χ.invFun x) ∈ ψ.source ->

* Log for [2024-09-25 Wed 11:19]

let V_f_x := ψ.source
let U_x := χ.source ∩ f ⁻¹' V_f_x
let chart_U : chart (EuclideanSpace ℝ (Fin m)) (M) :=
  { toFun := χ.toFun,
    invFun := χ.invFun,
    source := U_x,
    target := χ.target }

* Log for [2024-09-26 Thu 10:14]

 have h_foo : ∀ y ∈ interior (χ.source ∩ f ⁻¹' ψ.source), f y ∈ ψ.source := by
          intros y hy  -- Introduce the point y and the hypothesis that y is in the interior
          -- Since y is in the interior, it must be in the intersection
          have h_in_inter : y ∈ χ.source ∧ f ⁻¹' ψ.source := interior_subset (χ.source ∩ f ⁻¹' ψ.source) hy,

          -- From h_in_inter, extract that y is in χ.source and also f(y) is in ψ.source
          have h_f_inv : y ∈ f ⁻¹' ψ.source := h_in_inter.2, -- This gives us that y is in the preimage of ψ.source

          -- Now show that f(y) is in ψ.source
          exact h_f_inv  -- By definition of the preimage

       have h_bar : ∀ y ∈ interior (χ.source ∩ f ⁻¹' ψ.source), f y ∈ ψ.source := by
          intros y hy  -- Introduce the point y and the hypothesis
          -- Now you can use the properties of the interior and the openness of the sets
          have h_inter : y ∈ χ.source ∧ f y ∈ ψ.source := 
          -- Since y is in the interior of the intersection, it is in the intersection
            interior_subset (χ.source ∩ f ⁻¹' ψ.source) hy

          -- Now apply the image f to the point y
          exact h_inter.2  -- h_inter.2 will give you f(y) ∈ ψ.source


* Log for [2024-09-27 Fri 07:13]

I want to say that for all p in N the intersection of U and the
(source of the) chart at p is open and the union of all such sets
(over p) is open (and must equal U). I further want to say that the
image under the chart is open and then since ((chartAt (EuclideanSpace
ℝ (Fin n)) (f x)).toFun ∘ f ∘ (chartAt (EuclideanSpace ℝ (Fin m))
x).invFun) is continuous, i

I want for

theorem smooth_is_continuous {Homeomorph ψ : M -> (EuclideanSpace ℝ (Fin m))}
                             {Homeomorph φ : N -> (EuclideanSpace ℝ (Fin n))}
                             (f : M -> N): Continuous f := by

  rw [continuous_def] at *
  intro U hU
  by_cases hnU : (Nonempty U)
  have h_open_phiU : IsOpen (φ '' U) := by
      exact PartialHomeomorph.left_inv φ hU
  sorry

  -- Since U is open in N, φ(U) is open in ℝ^n (homeomorphism property)
  let U' := phi.toFun '' U

* Log for [2024-09-28 Sat 09:59]

have baz : id ∘ f = f := by
    funext x
    rfl
  
  have bar : (φ.invFun ∘ φ.toFun) ∘ f ∘ ψ.invFun = id ∘ f ∘ ψ.invFun := by
    rw [foo]

  have eek : id ∘ (f ∘ ψ.invFun) = f ∘ ψ.invFun := by
    funext x
    rfl

lemma fun_linv {α β : Type} (f : α → β) (g : β → α) (h_inv : ∀ x, g (f x) = x ∧ ∀ y, f (g y) = y) :
  g ∘ f = id := 
by
  funext x
  exact (h_inv x).1

lemma fun_rinv {α β : Type} (f : α → β) (g : β → α) (h_inv : ∀ x, g (f x) = x ∧ ∀ y, f (g y) = y) :
  f ∘ g = id := 
by
  funext y
  -- Apply g to y and then use h_inv
  have : f (g y) = y := (h_inv (g (f (g y)))).2 y
  exact this


have foo : φ.invFun ∘ φ.toFun = id := 
   funext φ.left_inv

  have urk : (φ.invFun ∘ φ.toFun) ∘ f ∘ ψ.invFun = f ∘ ψ.invFun := by
    rw [foo]
    funext x
    rfl

  have urg : (φ.invFun ∘ φ.toFun) ∘ f ∘ ψ.invFun = φ.invFun ∘ φ.toFun ∘ f ∘ ψ.invFun := by
    rw [fun_assoc]

  have arg : φ.invFun ∘ φ.toFun ∘ f ∘ ψ.invFun = f ∘ ψ.invFun := by
    rw [urg, foo]

  have brg : φ.invFun ∘ φ.toFun ∘ f ∘ ψ.invFun = φ.invFun ∘ (φ.toFun ∘ (f ∘ ψ.invFun)) := by
    exact


    have h_inv : ∀ x, φ.invFun (φ.toFun x) = x ∧ ∀ y, φ.toFun (φ.invFun y) = y := by
    intro x
    exact ⟨φ.left_inv x, φ.right_inv x⟩

  have h_inv : ∀ x, φ.invFun (φ.toFun x) = x ∧ ∀ y, φ.toFun (φ.invFun y) = y := by
    intro x
    exact ⟨φ.right_inv x, φ.left_inv x⟩

  have hg_postimageSimp : (φ.invFun ∘ φ.toFun) ∘ f ∘ ψ.invFun = f ∘ ψ.invFun := by
    apply foo φ.toFun φ.invFun f ψ.toFun
    sorry
* Log for [2024-09-29 Sun 08:41]

lemma fun_assoc {M N P Q : Type*}
 [TopologicalSpace M] [TopologicalSpace N] [TopologicalSpace P] [TopologicalSpace Q]
 {f : M → N} {g : N → P} {h : P → Q} : (h ∘ g) ∘ f = h ∘ (g ∘ f) := by
   funext x
   rfl

lemma fun_inv {α β γ : Type} (f : α → β) (g : β → α)
           (h1 : γ → α)
           (h_inv : ∀ x, g (f x) = x ∧ ∀ y, f (g y) = y) :
  (g ∘ f) ∘ h1 = id ∘ h1 :=
by
  funext x
  have LHS : (g ∘ f) (h1 (x)) = h1 (x) := (h_inv (h1 (x))).1
  exact LHS

theorem foo {α β γ : Type} (f : α → β) (g : β → α)
           (h : γ → α)
           (h_inv : ∀ x, g (f x) = x ∧ ∀ y, f (g y) = y) :
  (g ∘ f) ∘ h = h :=
by
  have bar : (g ∘ f) ∘ h = id ∘ h := fun_inv f g h h_inv
  rw [bar]
  funext x
  rfl

have hh : Continuous ψ.invFun := ψ.continuous_invFun
  rw [continuous_def] at *

  have qux : IsOpen (f ⁻¹' U) := hh ((ψ.invFun) ⁻¹' (f ⁻¹' U)) baz

* Log for [2024-09-30 Mon 15:46]

https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/Why.20does.20rewrite.20fail.3F/near/473438095

So you can do this

have baz_eq : f ∘ (ψ.invFun ∘ ψ.toFun) = f := by
      funext x
      have h : ψ.invFun (ψ.toFun x) = x := ψ.left_inv x
      rw [Function.comp_apply, Function.comp_apply]
      rw [h]

or trust the simplifier(?)

  have baz_eq : f ∘ (ψ.invFun ∘ ψ.toFun) = f := by
    simp

have harg : (f ⁻¹' U) = (ψ.toFun) ⁻¹' ((ψ.invFun) ⁻¹' (f  ⁻¹' U)) := by
    funext x
    have eek : (f ∘ (ψ.invFun ∘ ψ.toFun)) x = f x := by simp
    have aak : (f ∘ ψ.invFun ∘ ψ.toFun) x = f x := by simp
    have bbk : f (ψ.invFun (ψ.toFun x)) = f x := by simp [baz_eq]
    -- have fff : ∀ u ∈ (f  ⁻¹' U) f u ∈ U := ????
    sorry

  have garg  : f ⁻¹' U = (ψ.invFun ∘ ψ.toFun) ⁻¹' (f  ⁻¹' U) := by
    ext x
    simp only [Function.comp_apply]


    have baz_eq : f ∘ (ψ.invFun ∘ ψ.toFun) = f := by
    simp

  have harg : (f ⁻¹' U) = (ψ.toFun) ⁻¹' ((ψ.invFun) ⁻¹' (f  ⁻¹' U)) := by
    funext x
    have bbk : f (ψ.invFun (ψ.toFun x)) = f x := by simp [baz_eq]
    -- have fff : ∀ u ∈ (f  ⁻¹' U) f u ∈ U := ????
    sorry

* Log for [2024-10-01 Tue 09:35]

 lake	0.5	4.86	21	10	Apple	0.0	0.00	1885	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.0	0.21	1	0	Apple	0.0	0.00	1455	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.0	0.19	1	0	Apple	0.0	0.00	1465	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.4	4.69	21	9	Apple	0.0	0.00	1914	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.3	4.66	21	10	Apple	0.0	0.00	2046	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.5	4.80	21	10	Apple	0.0	0.00	1865	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.3	4.69	21	9	Apple	0.0	0.00	2060	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.4	5.00	21	9	Apple	0.0	0.00	1725	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lake	0.5	4.82	21	9	Apple	0.0	0.00	1943	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	3.34	11	1	Apple	0.0	0.00	1780	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	7.85	11	1	Apple	0.0	0.00	1694	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.26	9	1	Apple	0.0	0.00	1513	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	12.00	11	1	Apple	0.0	0.00	1667	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.07	6	1	Apple	0.0	0.00	1880	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.5	15.26	4	0	Apple	0.0	0.00	3950	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	7.12	11	1	Apple	0.0	0.00	1835	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.2	19.17	4	0	Apple	0.0	0.00	3855	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.35	6	1	Apple	0.0	0.00	1962	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	2.44	11	1	Apple	0.0	0.00	1568	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	5.17	11	1	Apple	0.0	0.00	1541	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	10.89	25	0	Apple	0.0	0.00	1505	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.06	6	1	Apple	0.0	0.00	2044	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.2	11.83	4	0	Apple	0.0	0.00	4064	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	1.82	7	1	Apple	0.0	0.00	1999	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.07	6	1	Apple	0.0	0.00	1904	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.0	12.10	4	0	Apple	0.0	0.00	4060	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.07	6	1	Apple	0.0	0.00	1936	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.5	11.27	4	0	Apple	0.0	0.00	4083	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	4.39	11	1	Apple	0.0	0.00	1583	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	11.63	4	0	Apple	0.0	0.00	4065	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	4.85	11	1	Apple	0.0	0.00	1633	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.3	13.82	4	0	Apple	0.0	0.00	4002	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	7.23	5	0	Apple	0.0	0.00	1502	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	3.94	11	1	Apple	0.0	0.00	1810	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.06	6	1	Apple	0.0	0.00	1860	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	11.00	4	0	Apple	0.0	0.00	4093	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.8	11.29	4	0	Apple	0.0	0.00	4084	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	7.28	11	1	Apple	0.0	0.00	1643	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	6.00	11	1	Apple	0.0	0.00	1752	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	2.53	11	1	Apple	0.0	0.00	1512	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.2	16.71	4	0	Apple	0.0	0.00	3917	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.9	17.55	4	0	Apple	0.0	0.00	3899	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.6	10.56	4	0	Apple	0.0	0.00	4103	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.06	6	1	Apple	0.0	0.00	2056	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	0.0	0.07	6	1	Apple	0.0	0.00	1721	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.3	9.31	5	0	Apple	0.0	0.00	4114	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.0	7.64	4	0	Apple	0.0	0.00	4159	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	10.9	7.69	4	0	Apple	0.0	0.00	4158	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.9	8.14	4	0	Apple	0.0	0.00	4154	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	10.9	7.23	4	0	Apple	0.0	0.00	4182	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.0	7.39	4	0	Apple	0.0	0.00	4178	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.4	7.33	4	0	Apple	0.0	0.00	4179	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	6.60	4	0	Apple	0.0	0.00	4204	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.0	5.95	4	0	Apple	0.0	0.00	4219	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.2	5.99	4	0	Apple	0.0	0.00	4215	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.0	5.46	4	0	Apple	0.0	0.00	4227	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	5.67	4	0	Apple	0.0	0.00	4223	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.0	5.13	4	0	Apple	0.0	0.00	4232	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.7	5.44	4	0	Apple	0.0	0.00	4224	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	4.70	4	0	Apple	0.0	0.00	4238	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.2	4.62	4	0	Apple	0.0	0.00	4240	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.3	4.58	4	0	Apple	0.0	0.00	4241	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.2	4.44	4	0	Apple	0.0	0.00	4242	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.0	3.97	4	0	Apple	0.0	0.00	4245	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.7	4.52	4	0	Apple	0.0	0.00	4244	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.1	3.96	4	0	Apple	0.0	0.00	4247	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.8	4.53	4	0	Apple	0.0	0.00	4243	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	4.00	4	0	Apple	0.0	0.00	4246	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.8	3.67	4	0	Apple	0.0	0.00	4252	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.5	3.62	4	0	Apple	0.0	0.00	4248	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.4	3.30	4	0	Apple	0.0	0.00	4257	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.1	3.69	4	0	Apple	0.0	0.00	4253	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.2	3.64	4	0	Apple	0.0	0.00	4249	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.6	3.47	4	0	Apple	0.0	0.00	4254	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.4	3.54	4	0	Apple	0.0	0.00	4250	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.9	3.37	4	0	Apple	0.0	0.00	4255	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	2.93	4	0	Apple	0.0	0.00	4259	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.6	2.92	4	0	Apple	0.0	0.00	4258	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.1	2.66	4	0	Apple	0.0	0.00	4261	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.8	2.34	4	0	Apple	0.0	0.00	4263	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.8	2.00	4	0	Apple	0.0	0.00	4266	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	13.5	2.15	4	0	Apple	0.0	0.00	4265	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	14.3	2.15	4	0	Apple	0.0	0.00	4264	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.7	1.31	4	0	Apple	0.0	0.00	4273	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	13.2	1.63	4	0	Apple	0.0	0.00	4270	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.5	1.60	4	0	Apple	0.0	0.00	4271	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	11.9	1.89	4	0	Apple	0.0	0.00	4267	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	14.8	1.59	2	0	Apple	0.0	0.00	4272	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.4	1.90	4	0	Apple	0.0	0.00	4268	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.7	1.02	4	0	Apple	0.0	0.00	4277	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.7	1.13	2	0	Apple	0.0	0.00	4276	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	12.4	0.80	2	0	Apple	0.0	0.00	4279	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	13.1	1.12	2	0	Apple	0.0	0.00	4275	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	13.1	0.96	2	0	Apple	0.0	0.00	4278	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	13.1	1.33	2	0	Apple	0.0	0.00	4274	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.24	2	0	Apple	0.0	0.00	4286	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.53	2	0	Apple	0.0	0.00	4282	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.11	2	0	Apple	0.0	0.00	4287	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.41	2	0	Apple	0.0	0.00	4283	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.39	2	0	Apple	0.0	0.00	4284	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.62	2	0	Apple	0.0	0.00	4280	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.29	2	0	Apple	0.0	0.00	4285	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 lean	(null)	0.57	2	0	Apple	0.0	0.00	4281	dom		0 bytes	0 bytes	0 bytes	No	No	No	(null)	No	0 bytes	0	0 bytes	0	0 bytes	0 bytes	0 bytes	-	0 bytes	0 bytes	No	(null)	
 

* Log for [2024-10-02 Wed 11:54]

  have baz_eq : f ∘ (ψ.invFun ∘ ψ.toFun) = f := by
      funext x
      have h : ψ.invFun (ψ.toFun x) = x := ψ.left_inv x
      rw [Function.comp_apply, Function.comp_apply]
      rw [h]

  have garg  : f ⁻¹' U = (ψ.invFun ∘ ψ.toFun) ⁻¹' (f  ⁻¹' U) := by
    ext x
    simp [Set.mem_preimage]

      have h_inv : ∀ (y : N), φ.invFun (φ.toFun y) = y ∧ ∀ (x : EuclideanSpace ℝ (Fin n)), φ.toFun (φ.invFun x) = x := by
    intro y
    exact ⟨φ.left_inv y, φ.right_inv⟩

  have hg_postimageSimp : (φ.invFun ∘ φ.toFun) ∘ f = f := by
    funext x
    exact φ.left_inv (f x)

* Log for [2024-10-03 Thu 09:35]

https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/difference.20between.20.60.3A.3D.20by.20rw.20.5Bh.5D.60.20and.20.60.3A.3D.20h.60

* Log for [2024-11-18 Mon 10:29]

  let U_inter := φ_α.source ∩ φ_β.source
  let φ_α_restricted : charted_space.chart M := {
    source := U_α ∩ U_β,
    to_fun := φ_α.to_fun,
    inv_fun := φ_α.inv_fun,
    left_inv := λ x hx, φ_α.left_inv hx.1,
    right_inv := λ y hy, φ_α.right_inv hy.1
  }

       have h1g : φ_α.invFun ⁻¹' (φ_α.source ∩ φ_β.source) =
                (φ_α.invFun ⁻¹' φ_α.source) ∩ (φ_α.invFun ⁻¹' φ_β.source) := Set.preimage_inter

* Log for [2024-11-19 Tue 08:41]

(φ_α.invFun ∘ φ_α.toFun) '' (φ_α.source ∩ φ_β.source) =
                     φ_α.invFun '' (φ_α.toFun '' (φ_α.source ∩ φ_β.source))

(f ∘ g) '' A = f '' (g '' A)

* Log for [2024-11-21 Thu 09:26]

example
  (f : M → ℝ)
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Α : φ_α ∈ atlas (EuclideanSpace ℝ (Fin m)) M)
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Β : φ_β ∈ atlas (EuclideanSpace ℝ (Fin m)) M) :

      let Dg : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] ℝ) :=
        λ x => fderiv ℝ (f ∘ φ_α.invFun)
                        (φ_α.toFun x)

      let Dh : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] ℝ) :=
        λ x => fderiv ℝ (f ∘ φ_β.invFun)
                        (φ_β.toFun x)

      ∀ x ∈ φ_α.source ∩ φ_β.source, (∀ v, Dg x v = 0) <-> (∀ v, Dh x v = 0) := by

  let g := f ∘ φ_α.invFun
  let h := f ∘ φ_β.invFun
  let B := φ_α.source ∩ φ_β.source
  let A := φ_α.toFun '' B
  let p := f ∘ (φ_β.invFun ∘ φ_β.toFun)

  have h0 : g '' A = (h ∘ φ_β.toFun ∘ φ_α.invFun) '' A :=
    -- have h01 : g '' A = (f ∘ φ_α.invFun) '' A := rfl
    -- have h02 : (h ∘ φ_β.toFun ∘ φ_α.invFun) '' A  = (f ∘ φ_β.invFun ∘ φ_β.toFun ∘ φ_α.invFun) '' A := rfl
    -- have h03 : (f ∘ φ_β.invFun ∘ φ_β.toFun ∘ φ_α.invFun) '' A =
    --            (f ∘ (φ_β.invFun ∘ φ_β.toFun) ∘ φ_α.invFun) '' A := rfl
    -- have h07 : (φ_α.invFun ∘ φ_α.toFun) '' B = φ_α.invFun '' (φ_α.toFun '' B) := by rw [<-Set.image_comp]
    -- have h03 : (p ∘ φ_α.invFun) ''         A = p '' (φ_α.invFun '' A)         := by rw [Set.image_comp]
    -- have h04 : p '' (φ_α.invFun '' A)  = p '' (φ_α.invFun '' (φ_α.toFun '' B)) := rfl
    have h05 : ∀ y, y ∈ φ_α.source -> φ_α.invFun (φ_α.toFun y) = y := λ h hy => φ_α.left_inv hy
    have h04 : φ_α.source ∩ φ_β.source ⊆ (φ_α.invFun '' (φ_α.toFun '' (φ_α.source ∩ φ_β.source))) := by
      intros x hx
      have h04a : x ∈ φ_α.source := hx.1
      have h04b : φ_α.invFun (φ_α.toFun x) = x := h05 _ h04a
      have h04z : (φ_α.invFun ∘ φ_α.toFun) x = φ_α.invFun (φ_α.toFun x) := rfl
      have h04y : (φ_α.invFun ∘ φ_α.toFun) x = x := by
        rw [h04z]
        exact h04b
      have h04c : (φ_α.invFun ∘ φ_α.toFun) x ∈ (φ_α.invFun ∘ φ_α.toFun) '' (φ_α.source ∩ φ_β.source) := by
        exact Set.mem_image_of_mem (φ_α.invFun ∘ φ_α.toFun) hx
      have h04d : x ∈ (φ_α.invFun ∘ φ_α.toFun) '' (φ_α.source ∩ φ_β.source) :=
        by rw [h04y] at h04c
           exact h04c
      have h04e : (φ_α.invFun ∘ φ_α.toFun) '' (φ_α.source ∩ φ_β.source) =
                  φ_α.invFun '' (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) := by rw [<-Set.image_comp]
      rw [h04e] at h04d
      exact h04d
    sorry

type mismatch
  Set.mem_image (φ_α.invFun ∘ ↑φ_α.toPartialEquiv) (φ_α.source ∩ φ_β.source)
has type

∀ (x : M),
    x ∈ φ_α.invFun ∘ ↑φ_α.toPartialEquiv '' (φ_α.source ∩ φ_β.source) ↔
      ∃ z ∈ φ_α.source ∩ φ_β.source, (φ_α.invFun ∘ ↑φ_α.toPartialEquiv) z = x : Prop

but is expected to have type
  x ∈ φ_α.invFun ∘ ↑φ_α.toPartialEquiv '' (φ_α.source ∩ φ_β.source) ↔
    ∃ z ∈ φ_α.source ∩ φ_β.source, (φ_α.invFun ∘ ↑φ_α.toPartialEquiv) z = x : Prop

I have

  (f : M → ℝ)
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Α : φ_α ∈ atlas (EuclideanSpace ℝ (Fin m)) M)
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Β : φ_β ∈ atlas (EuclideanSpace ℝ (Fin m)) M) :

  have h02 : φ_α.source ∩ φ_β.source ⊆ (φ_α.invFun '' (φ_α.toFun '' (φ_α.source ∩ φ_β.source))) := by
  have h03 : (φ_α.invFun '' (φ_α.toFun '' (φ_α.source ∩ φ_β.source))) ⊆  φ_α.source ∩ φ_β.source := by

and thus

  have h04 : φ_α.source ∩ φ_β.source = φ_α.invFun '' (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) := by

But now I need

φ_α.source ∩ φ_β.source = φ_β.invFun '' (φ_β.toFun '' (φ_α.source ∩ φ_β.source))

The proof will be almost identical so I shouldn't need to do it again?

have h06 : φ_α.source ∩ φ_β.source = φ_β.invFun '' (φ_β.toFun '' (φ_α.source ∩ φ_β.source)) :=
  by rw [←h04]

* Log for [2024-11-23 Sat 10:54]


open Real

@[simp] lemma deriv_one_minus (x : ℝ) : deriv (fun (y : ℝ) ↦ 1 - y) x = -1 := by
  have onem (y : ℝ) : 1 - y = -(y + -1) := by ring
  simp_rw [onem]
  simp

@[simp] lemma diff_1_minusp (p : ℝ) : DifferentiableAt ℝ (fun p => 1 - p) p := by
  have (p : ℝ) : 1 - p = -(p - 1) := by ring
  simp_rw [this]
  apply differentiableAt_neg_iff.mpr
  apply DifferentiableAt.add_const
  simp

lemma deriv_log_one_sub (x : ℝ) (hh : x ≠ 1): deriv (fun p ↦ log (1 - p)) x = -(1-x)⁻¹ := by
  have (x : ℝ) : log (1 - x) = ((fun x ↦ log x) ∘ (1 - ·)) x := by simp
  simp_rw [this]
  rw [deriv.comp]  -- How to apply chain rule without this ugly hack?
  · simp
  · simp
    exact sub_ne_zero.mpr hh.symm
  · simp

* Log for [2024-11-26 Tue 14:20]

As part of my journey to learn lean I thought I would prove a fairly
simple fact about smooht differential manifolds: that the vanishing of a
derivative is co-ordinate invariant or more simply if a derivative
vanishes in one chart then it vanishes in any other.

Let $f : M \longrightarrow \mathbb{R}$ be smooth then $g :=
f\phi_\alpha^{-1}$ is $C^\infty$. Suppose its derivative vanishes at
$\phi_\alpha(a) = (x_1(a), x_2(a), \ldots, x_n(a))$. Now take another
chart and define $h := f\phi_\beta^{-1}$

$$
g = f \varphi_\alpha^{-1}=f \varphi_\beta^{-1} \varphi_\beta \varphi_\alpha^{-1}=h \varphi_\beta \varphi_\alpha^{-1}
$$

which we can write as

$$
g\left(x_1, \ldots, x_n\right)=h\left(y_1(x), \ldots, y_n(x)\right)
$$

By the chain rule we have

$$
\frac{\partial g}{\partial x_i}\Big|_{\phi_\alpha(a)} = \sum_j \frac{\partial h}{\partial y_j}\Big|_{\phi_\beta(a)} \frac{\partial y_j}{\partial x_i}\Big|_{\phi_\alpha(a)}
$$

Since $\phi_\alpha$ and $\phi_\beta$ are charts on a smooth manifold
$\varphi_\beta \varphi_\alpha^{-1}$ is invertible with a Jacobian of
full rank (at $a$).

Thus $D g_{x(a)} = 0$ if and only if $D h_{y(a)} = 0$

So this is what I have


* Log for [2024-12-14 Sat 08:12]

HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin 1)) (h ∘ ↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x)
    ((Dh x).comp (Dαβ x))

    have h41 : (φ_α.symm ≫ₕ φ_β) (φ_α x) = (φ_β x) := by
      rw [PartialHomeomorph.trans_apply]
      congr
      exact PartialHomeomorph.left_inv φ_α (Set.mem_of_mem_inter_left hx)

    have h47 : HasMFDerivAt (𝓡 m) (𝓡 m)  (φ_α.symm.trans φ_β) ((φ_α.symm ≫ₕ φ_β) (φ_α x)) (Dαβ x) := by
      sorry

    -- have baa : true := by
    --   apply HasMFDerivAt.comp (φ_α x) hhAkag h31

    have baa : HasMFDerivAt (𝓡 m) (𝓡 m) (↑(φ_α.symm ≫ₕ φ_β) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α x) ((Dαβ x).comp (Dαβ x)) := by
      apply HasMFDerivAt.comp (φ_α x) h47 h31

    -- HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin 1)) h (↑φ_β x) (Dh x)
    -- HasMFDerivAt ?m.103379 ?m.103388 ?m.103401 (↑φ_α x) ?m.103432

    have h53 : HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin 1)) h (φ_β x) (Dh x) := by
      sorry

    have h59 : HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin 1)) h (φ_α x) (Dh x) := by
      sorry

    have h61 : HasMFDerivAt (𝓡 m) (𝓡 1) h ((φ_α.symm ≫ₕ φ_β) (φ_α x)) (Dh x) := by
      sorry

    have baa : HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin 1)) (h ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α x) ((Dh x).comp (Dαβ x)) := by
      apply HasMFDerivAt.comp (φ_α x) h61 h31

    -- have baa : HasMFDerivAt (𝓡 m) (𝓡 m) (h ∘ ((φ_α.symm.trans φ_β).toFun)) (φ_α x) ((Dh x).comp (Dαβ x)) := sorry
    have baa : HasMFDerivAt (𝓡 m) (𝓡 1) (h ∘ ((φ_α.symm.trans φ_β).toFun)) (φ_α x) ((Dh x).comp (Dαβ x)) := by
      apply HasMFDerivAt.comp (φ_α x) h61 h31

    -- have h37 : HasMFDerivAt (𝓡 m) (𝓡 1) (h ∘ ((φ_α.symm.trans φ_β))) (φ_α x) ((Dh x).comp (Dαβ x)) := sorry -- HasMFDerivAt.comp (φ_α x) sorry sorry -- hhAkag h31
    -- have h37 : HasMFDerivAt (𝓡 m) (𝓡 1) sorry sorry sorry := HasMFDerivAt.comp sorry sorry sorry
    sorry


tactic 'apply' failed, failed to unify
  HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x✝) ((Dβα x✝).comp (Dαβ x✝))
with
  HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x) ((Dβα x).comp (Dαβ x))


tactic 'apply' failed, failed to unify
  HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x)
    (mfderiv 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β))
      (↑φ_α x))
with
  HasMFDerivAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x)
    (mfderivWithin 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm)
      (↑φ_α.toPartialEquiv '' (φ_α.source ∩ φ_β.source)) (↑φ_α x))

* Log for [2024-12-16 Mon 10:59]

  have hb : mfderiv (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α x) =
              mfderivWithin (𝓡 m) (𝓡 m) id (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) (φ_α x) := by
              sorry

have hc : mfderiv (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) =
            mfderiv (𝓡 m) (𝓡 m) id (φ_α x) := by
              have h1 : mfderivWithin (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) (φ_α x) =
                        mfderiv (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) = by
                          apply MDifferentiable.mfderivWithin sorry sorry
                          sorry
              sorry







  have ha : MDifferentiableWithinAt (𝓡 m) (𝓡 m) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) (φ_α x) := by
    apply sorry

  have he : HasMFDerivWithinAt (𝓡 m) (𝓡 m) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) (φ_α x)
              (mfderivWithin (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) (φ_α x)) := by
                apply MDifferentiableWithinAt.hasMFDerivWithinAt ha

  have ha : MDifferentiableAt (𝓡 m) (𝓡 m) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α x) := by
    apply sorry

  have he : HasMFDerivAt (𝓡 m) (𝓡 m) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α x)
              (mfderiv (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α x)) := by
                apply MDifferentiableAt.hasMFDerivAt ha

  -- have hc : mfderiv (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) =
  --           mfderiv (𝓡 m) (𝓡 m) id (φ_α x) := by
  --             sorry

  have hd : HasMFDerivAt
            (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x)
            (mfderiv (𝓡 m) (𝓡 m) id (φ_α x)) := by
            rw [<-hc]
            exact he

  have h9 : true := by
    have h1 : HasMFDerivAt (𝓡 m) (𝓡 m) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α x)
              (mfderiv (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α x)) := by
                apply MDifferentiableAt.hasMFDerivAt ha
    sorry

* Log for [2024-12-17 Tue 16:16]


I have

```lean4
  let Dαβ : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m)) :=
    λ x => mfderiv (𝓡 m) (𝓡 m) ((φ_α.symm.trans φ_β).toFun) (φ_α.toFun x)

  let Dβα : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m)) :=
    λ x => mfderiv (𝓡 m) (𝓡 m) ((φ_β.symm.trans φ_α).toFun) (φ_β.toFun x)
```

and

```lean4
  have h1 :
    ContinuousLinearMap.id ℝ (TangentSpace (𝓡 m) (φ_α x)) = (Dβα x).comp (Dαβ x) := by
      sorry
```

but I'd really like to write what I would on paper. Maybe this is possible in the category of continuous linear maps?


```lean4
  have h1 :
    id = (Dβα x) ∘ (Dαβ x) := by
      sorry
```

** The Example

example
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Α : φ_α ∈ maximalAtlas (𝓡 m) M)
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Β : φ_β ∈ maximalAtlas (𝓡 m) M)

  (x : M) (hx : x ∈  φ_α.source ∩ φ_β.source) :

  let Dαβ : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m)) :=
    λ x => mfderiv (𝓡 m) (𝓡 m) ((φ_α.symm.trans φ_β).toFun) (φ_α.toFun x)

  let Dβα : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m)) :=
    λ x => mfderiv (𝓡 m) (𝓡 m) ((φ_β.symm.trans φ_α).toFun) (φ_β.toFun x)

  ContinuousLinearMap.id ℝ (TangentSpace (𝓡 m) (φ_α x)) = (Dβα x)  ∘L (Dαβ x) := by

  let Dαβ : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m)) :=
    λ x => mfderiv (𝓡 m) (𝓡 m) ((φ_α.symm.trans φ_β).toFun) (φ_α.toFun x)

  let Dβα : M -> (EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m)) :=
    λ x => mfderiv (𝓡 m) (𝓡 m) ((φ_β.symm.trans φ_α).toFun) (φ_β.toFun x)

  let MyId : TangentSpace (𝓡 m) (φ_α x) →L[ℝ] TangentSpace (𝓡 m) (φ_α x) :=
    ContinuousLinearMap.id ℝ (TangentSpace (𝓡 m) (φ_α x))

  have linear_map_equality :
    MyId = (Dβα x)  ∘L (Dαβ x) := by
     apply sorry

  exact linear_map_equality

variable
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]

variable (x : M)

#check ContinuousLinearMap.id ℝ (TangentSpace (𝓡 m) x)

** Other

* Log for [2024-12-19 Thu 15:20]

  have h3 : mfderiv (𝓡 m) (𝓡 1) (g ∘ (φ_β ∘ ↑φ_α.symm)) (φ_α x) = sorry := by
    (mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) x)).comp (Dab m φ_α φ_β x)

 -- let s := (φ_α.toFun '' (φ_α.source ∩ φ_β.source))

  -- have h1 : .id _ _ = (Dab m φ_β φ_α x) ∘L (Dab m φ_α φ_β x) := by
  --   exact inverse_transition_of_transition m φ_α hΦ_Α φ_β hΦ_Β x hx

  -- have h2 : .id _ _ = (Dab m φ_α φ_β x) ∘L (Dab m φ_β φ_α x) := by
  --   have hy : x ∈ φ_β.source ∩ φ_α.source := by
  --     rw [Set.inter_comm]
  --     assumption
  --   exact inverse_transition_of_transition m φ_β hΦ_Β φ_α hΦ_Α x hy

  -- have h3 : mfderiv (𝓡 m) (𝓡 1) (g ∘ (φ_β ∘ ↑φ_α.symm)) (φ_α x) = sorry := by
  --   have h0 : TangentSpace (𝓡 m) (φ_β x) →L[ℝ] TangentSpace (𝓡 1) (g (φ_β x)) :=
  --    mfderiv (𝓡 m) (𝓡 1) g (φ_β x)
  --   have h2 : EuclideanSpace ℝ (Fin m) →L[ℝ] EuclideanSpace ℝ (Fin m) := Dab m φ_α φ_β x
  --   have h1 :  EuclideanSpace ℝ (Fin m) →L[ℝ] TangentSpace (𝓡 1) (g ((↑φ_β ∘ ↑φ_α.symm) (φ_α x))) :=
  --    (mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x))).comp (Dab m φ_α φ_β x)
  --   calc 0 = mfderiv (𝓡 m) (𝓡 1) (g ∘ (φ_β ∘ ↑φ_α.symm)) (φ_α x)
  --        _ = (mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x))).comp (Dab m φ_α φ_β x) := sorry
  --   sorry

  -- have h3 : mfderiv (𝓡 m) (𝓡 1) (g ∘ (φ_β ∘ ↑φ_α.symm)) (φ_α x) = sorry := by
  -- -- mfderiv (𝓡 m) (𝓡 1) g (φ_β.toFun x)
  --   sorry
  -- sorry

* Log for [2024-12-20 Fri 11:25]


  have h5 : f ∘L  ((Dab m φ_α φ_β x)) ∘L (Dab m φ_β φ_α x) =
             f ∘L  (.id _ _) := by
     have h1 : (.id _ _) = (Dab m φ_α φ_β x) ∘L (Dab m φ_β φ_α x) := by
       sorry -- I have a proof for this
     rw [<-h1]
     sorry

  have h1 : mfderiv (𝓡 m) (𝓡 1) (g ∘ (φ_β ∘ ↑φ_α.symm)) (φ_α x) =
            (mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x))) ∘L  (Dab m φ_α φ_β x) := by

  have h2 : (mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x))) ∘L  (Dab m φ_α φ_β x) = 0 := by

  have h3 : ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x))) ∘L  (Dab m φ_α φ_β x)) ∘L (Dab m φ_β φ_α x) =
            0 ∘L (Dab m φ_β φ_α x) := by

  have h4 : ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x))) ∘L  (Dab m φ_α φ_β x)) ∘L (Dab m φ_β φ_α x) =
            ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x)))) ∘L  ((Dab m φ_α φ_β x)) ∘L (Dab m φ_β φ_α x) := by

  have h5 : ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x)))) ∘L  ((Dab m φ_α φ_β x)) ∘L (Dab m φ_β φ_α x) =
             ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x)))) ∘L  (.id _ _) := by

  have h6 : ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x)))) ∘L  (.id _ _) =
            ((mfderiv (𝓡 m) (𝓡 1) g ((φ_β  ∘ ↑φ_α.symm) (φ_α x)))) := by

* Log for [2024-12-21 Sat 18:27]

    have hz :  mfderiv (𝓡 m) (𝓡 1) ((f ∘ φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) = 0 →
               mfderiv (𝓡 m) (𝓡 1) (f ∘ φ_β.symm) (φ_β x) = 0 := by
     intro hx
     have hz1 : mfderiv (𝓡 m) (𝓡 1) ((f ∘ φ_β.symm) ∘ φ_β ∘ φ_α.symm) (φ_α x) =
                mfderiv (𝓡 m) (𝓡 1) (((f ∘ φ_β.symm) ∘ φ_β) ∘ φ_α.symm) (φ_α x) := by
       rfl
     let k := (f ∘ φ_β.symm) ∘ φ_β
     let a := φ_α x
     have h2y : (k ∘ φ_α.symm) a = 
     have hz2 : mfderiv (𝓡 m) (𝓡 1) (k ∘ φ_α.symm) a =
                mfderiv (𝓡 m) (𝓡 1) k (φ_α.symm a) := by
                simp only [Function.comp_apply]
     sorry

         have h7 : ∀ x ∈ (φ_α.source ∩ φ_β.source),
      mfderiv (𝓡 m) (𝓡 1) (f ∘ φ_β.symm) ((↑φ_β ∘ ↑φ_α.symm) (φ_α x)) =
      mfderiv (𝓡 m) (𝓡 1) (f ∘ ↑φ_β.symm) (φ_β x) := by
      sorry


  ((f ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) ∘ ↑φ_α

      -- have h6b : ∀ x ∈ φ_α.source ∩ φ_β.source,
    -- mfderivWithin (𝓡 m) (𝓡 1) ((f ∘ ↑φ_β.symm) ∘ (↑φ_β ∘ ↑φ_α.symm) ∘ ↑φ_α) (φ_α.source ∩ φ_β.source) x =
    -- mfderivWithin (𝓡 m) (𝓡 1) (f ∘ ↑φ_α.symm ∘ ↑φ_α) (φ_α.source ∩ φ_β.source) x :=
    --     mfderivWithin_congr_of_eq_on_open ((f ∘ φ_β.symm) ∘ (φ_β ∘ φ_α.symm) ∘ φ_α) (f ∘ φ_α.symm ∘ φ_α)  (φ_α.source ∩ φ_β.source) sorry sorry

    -- have h6c : ∀ x ∈ φ_α.source ∩ φ_β.source,
    -- mfderiv (𝓡 m) (𝓡 1) (((f ∘ ↑φ_β.symm) ∘ (↑φ_β ∘ ↑φ_α.symm)) ∘ ↑φ_α) x =
    -- mfderiv (𝓡 m) (𝓡 1) (f ∘ ↑φ_α.symm ∘ ↑φ_α) x := by
    --   sorry

* Log for [2024-12-23 Mon 11:12]


example {α β : Type _} [TopologicalSpace α] {f g : α → β} {t : Set α} {y : α}
  (ht : IsOpen t) (hy : y ∈ t) (h : ∀ x ∈ t, f x = g x) :
  f =ᶠ[nhds y] g := by
  have h1 : t ∈ nhds y := IsOpen.mem_nhds

  theorem baz {α β : Type*} (f : α → β) (s : Set α) (x : α) (hx : x ∈ s) :
 f x ∈ Set.image f s := ⟨x, hx, rfl⟩


* Log for [2024-12-24 Tue]

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>My Blog</title>

  <!-- MathJax Configuration -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>

  <!-- MathJax Script -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <h1>Welcome to My Blog</h1>
  <p>Here is an inline equation: \( E = mc^2 \).</p>
  <p>Here is a block equation:</p>
  <div>
    \[
    \int_a^b f(x) dx = F(b) - F(a)
    \]
  </div>
</body>
</html>

  ContMDiffAt 𝓘(?m.17705, ?m.17707)          𝓘(?m.17705, ?m.17710)          ?m.17713 ?m.17714              ?m.17715 → ContDiffAt ?m.17705 ↑?m.17713 ?m.17714               ?m.17715
  ContMDiffAt 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) 𝓘(ℝ, EuclideanSpace ℝ (Fin m)) ⊤        (↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x) → ContDiffAt ℝ        ⊤         (↑(φ_α.symm ≫ₕ φ_β)) (↑φ_α x)

* Log for [2024-12-28 Sat 11:36]

theorem contMDiffAt_finsum0 {x₀ : M} {g : ι → M → F}
    (hφ : ∀ i, x₀ ∈ tsupport (f i) → ContMDiffAt I 𝓘(ℝ, F) n (g i) x₀) :
    ContMDiffAt I 𝓘(ℝ, F) n (fun x ↦ ∑ᶠ i, f i x • g i x) x₀ := by
  refine _root_.contMDiffAt_finsum (f.locallyFinite.smul_left _) fun i ↦ ?_
  by_cases hx : x₀ ∈ tsupport (f i)
  · exact ContMDiffAt.smul ((f i).contMDiff.of_le le_top).contMDiffAt (hφ i hx)
  · exact contMDiffAt_of_not_mem (compl_subset_compl.mpr
      (tsupport_smul_subset_left (f i) (g i)) hx) n




open Function Filter Module Set
open scoped Topology Manifold

variable [NormedAddCommGroup E] [NormedSpace ℝ E]
  [NormedAddCommGroup F] [NormedSpace ℝ F]
  [TopologicalSpace H] (I : ModelWithCorners ℝ E H) [TopologicalSpace M]
  [ChartedSpace H M]

variable {s : Set M} (f : SmoothPartitionOfUnity ι I M s) {n : ℕ∞}

theorem contMDiffAt_finsum0 {x₀ : M} {g : ι → M → F}
    (hφ : ∀ i, x₀ ∈ tsupport (f i) → ContMDiffAt I 𝓘(ℝ, F) n (g i) x₀) :
    ContMDiffAt I 𝓘(ℝ, F) n (fun x ↦ ∑ᶠ i, f i x • g i x) x₀ := by
  sorry

theorem contDiffAt_finsum0 {s : Set E} (f : SmoothPartitionOfUnity ι 𝓘(ℝ, E) E s) {x₀ : E}
    {g : ι → E → F} (hφ : ∀ i, x₀ ∈ tsupport (f i) → ContDiffAt ℝ n (g i) x₀) :
    ContDiffAt ℝ n (fun x ↦ ∑ᶠ i, f i x • g i x) x₀ := by
  simp only [← contMDiffAt_iff_contDiffAt] at *
  exact f.contMDiffAt_finsum hφ


#check fderivWithin
#check IsOpen.uniqueDiffWithinAt sorry
#check IsOpen.uniqueMDiffWithinAt sorry
#check fderivWithin_congr
#check mfderivWithin_congr

def f : EuclideanSpace ℝ (Fin 1) -> EuclideanSpace ℝ (Fin 1) := λ x => x
def g : EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1) := λ x => -x
def s : Set (EuclideanSpace ℝ (Fin 1)) := {λ _ : Fin 1 => (0 : ℝ)}

example : (∀ x ∈ s, f x = g x) → ∀ x ∈ s, fderivWithin ℝ f s x = fderivWithin ℝ g s x  := by
  intro h_eq
  apply fderivWithin_congr_of_eq_on_open f g {0} h_eq

* Log for [2025-01-01 Wed 15:07]

I have managed to prove that if $$\phi_\beta \phi_\alpha^{-1}$$ is a transition map of a smooth manifold and $$\phi_\alpha \phi_\beta^{-1}$$ is its (smooth) inverse then D(


```lean4
theorem inverse_transition_of_transition
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Α : φ_α ∈ maximalAtlas (𝓡 m) M)
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Β : φ_β ∈ maximalAtlas (𝓡 m) M)

  (x : M) (hx : x ∈  φ_α.source ∩ φ_β.source) :

  .id _ _ = (mfderiv (𝓡 m) (𝓡 m) (φ_β.symm ≫ₕ φ_α) (φ_β x)) ∘L (mfderiv (𝓡 m) (𝓡 m) (φ_α.symm ≫ₕ φ_β) (φ_α x)) := by
    sorry
```

```lean4
import Mathlib
open Manifold
open SmoothManifoldWithCorners

noncomputable def Dab
  (m : ℕ)
  {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (x : M) :
  (EuclideanSpace ℝ (Fin m)) →L[ℝ] (EuclideanSpace ℝ (Fin m)) :=
  mfderiv (𝓡 m) (𝓡 m) (φ_α.symm ≫ₕ φ_β) (φ_α x)

theorem h_equiv (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (x : M) (hx : x ∈  φ_α.source ∩ φ_β.source) :
    ((↑φ_β ∘ ↑φ_α.symm) (φ_α x)) = (φ_β x) := by
      calc ((↑φ_β ∘ ↑φ_α.symm) (φ_α x)) =
               φ_β (φ_α.symm (φ_α x)) := by rfl
           _ = φ_β x := by rw [φ_α.left_inv hx.1]

theorem inverse_of_chart_transition
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (x : M) (hx : x ∈  φ_α.source ∩ φ_β.source) :
  ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α x) = (φ_α x) := by
    have hy : x ∈ φ_β.source ∩ φ_α.source := by
      rw [Set.inter_comm]
      assumption

    rw [Function.comp_apply]
    rw [h_equiv m φ_α φ_β x hx]
    rw [h_equiv m φ_β φ_α x hy]

theorem mfderivWithin_congr_of_eq_on_open
  {m n : ℕ} {M N : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  [TopologicalSpace N]
  [ChartedSpace (EuclideanSpace ℝ (Fin n)) N]
  [SmoothManifoldWithCorners (𝓡 n) N]
  (f g : M → N) (s : Set M)
  (ho : IsOpen s)
  (he : ∀ x ∈ s, f x = g x) :
  ∀ x ∈ s, mfderivWithin (𝓡 m) (𝓡 n) f s x = mfderivWithin (𝓡 m) (𝓡 n) g s x := by
    intro z hz
    exact mfderivWithin_congr (IsOpen.uniqueMDiffWithinAt ho hz) he (he z hz)

 theorem contMDiffAt_chart_transition
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Α : φ_α ∈ maximalAtlas (𝓡 m) M)
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Β : φ_β ∈ maximalAtlas (𝓡 m) M)
  (x : M)  (hx : x ∈  φ_α.source ∩ φ_β.source) :
   ContMDiffAt (𝓡 m) (𝓡 m) ⊤ (φ_α.symm.trans φ_β) (φ_α x) := by
    have h1 : (φ_α.symm.trans φ_β) = φ_β ∘ φ_α.symm :=
      PartialHomeomorph.coe_trans φ_α.symm φ_β
    have h2 : ContMDiffAt (𝓡 m) (𝓡 m) ⊤ φ_β x :=
      contMDiffAt_of_mem_maximalAtlas hΦ_Β hx.2
    have h3 : ContMDiffAt (𝓡 m) (𝓡 m) ⊤ φ_α.symm (φ_α x) :=
      contMDiffAt_symm_of_mem_maximalAtlas hΦ_Α (PartialHomeomorph.map_source φ_α hx.1)
    have h4 : φ_α.symm (φ_α x) = x := PartialHomeomorph.left_inv φ_α hx.1
    have h5 : ContMDiffAt (𝓡 m) (𝓡 m) ⊤ φ_β (φ_α.symm (φ_α x)) := by
      rw [h4]
      exact h2
    have h7 : ContMDiffAt (𝓡 m) (𝓡 m) ⊤ (φ_β ∘ φ_α.symm) (φ_α x) :=
      ContMDiffAt.comp (I' := 𝓡 m) (φ_α x) h5 h3
    have h8 : ContMDiffAt (𝓡 m) (𝓡 m) ⊤ (φ_α.symm.trans φ_β) (φ_α x) := by
      rw [h1]
      exact h7
    exact h8

theorem open_image_of_inter_sources
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m))) :
   IsOpen (φ_α.toFun '' (φ_α.source ∩ φ_β.source)) := by
    have ho : IsOpen (φ_α.source ∩ φ_β.source) := by
      have ho1 : IsOpen φ_α.source := φ_α.open_source
      have ho2 : IsOpen φ_β.source := φ_β.open_source
      exact IsOpen.and ho1 ho2
    have hs : φ_α.source ∩ φ_β.source ⊆  φ_α.source := inf_le_left
    have h2 : φ_α.toFun = φ_α := φ_α.toFun_eq_coe
    rw [h2]
    have h1 := φ_α.isOpen_image_iff_of_subset_source hs
    rw [h1]
    exact ho

theorem inverse_transition_of_transition
  (m : ℕ) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace ℝ (Fin m)) M]
  [SmoothManifoldWithCorners (𝓡 m) M]
  (φ_α : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Α : φ_α ∈ maximalAtlas (𝓡 m) M)
  (φ_β : PartialHomeomorph M (EuclideanSpace ℝ (Fin m)))
  (hΦ_Β : φ_β ∈ maximalAtlas (𝓡 m) M)

  (x : M) (hx : x ∈  φ_α.source ∩ φ_β.source) :

  .id _ _ = (Dab m φ_β φ_α x) ∘L (Dab m φ_α φ_β x) := by

  let Dαβ := Dab m φ_α φ_β
  let Dβα := Dab m φ_β φ_α
  let s := φ_α.toFun '' (φ_α.source ∩ φ_β.source)

  have h1 : HasMFDerivAt (𝓡 m) (𝓡 m)  (φ_α.symm ≫ₕ φ_β) (φ_α x) (Dαβ x) := by
    apply MDifferentiableAt.hasMFDerivAt (ContMDiffAt.mdifferentiableAt (contMDiffAt_chart_transition m φ_α hΦ_Α φ_β hΦ_Β x hx) le_top)

  have h2 : HasMFDerivAt (𝓡 m) (𝓡 m)  (φ_β.symm ≫ₕ φ_α) (φ_β x) (Dβα x) := by
    have hy : x ∈ φ_β.source ∩ φ_α.source := by
       rw [Set.inter_comm]
       assumption
    exact MDifferentiableAt.hasMFDerivAt (ContMDiffAt.mdifferentiableAt (contMDiffAt_chart_transition m φ_β hΦ_Β φ_α hΦ_Α x hy) le_top)

  have h2_rw : HasMFDerivAt (𝓡 m) (𝓡 m) (φ_β.symm ≫ₕ φ_α) ((φ_α.symm ≫ₕ φ_β) (φ_α x)) (Dβα x) := by
    have h2_rwa : (φ_α.symm ≫ₕ φ_β) (φ_α x) = (φ_β x) := h_equiv m φ_α φ_β x hx
    rw [h2_rwa]
    exact h2

  have h_inv1 : ∀ x ∈ φ_α.source ∩ φ_β.source,
  ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α x) = (φ_α x) := by
   exact inverse_of_chart_transition m φ_α φ_β

  have h_inv2 : ∀ x ∈ s,
    ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) x = id x := by
    intro x hx
    obtain ⟨y, hy, hfy⟩ := (Set.mem_image ↑φ_α.toPartialEquiv (φ_α.source ∩ φ_β.source) x).mp hx
    have h := h_inv1 y hy
    rw [←hfy]
    exact h

  have h3 : ∀ x ∈ s,
    mfderivWithin (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) s x =
    mfderivWithin (𝓡 m) (𝓡 m) id s x :=
      mfderivWithin_congr_of_eq_on_open ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) id s (open_image_of_inter_sources m φ_α φ_β) h_inv2

  have h4 : φ_α x ∈ s := by
      exact ⟨x, hx, rfl⟩

  have h5 : mfderivWithin (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) s (φ_α x) =
              mfderivWithin (𝓡 m) (𝓡 m) id s (φ_α x) := by
              apply h3 (φ_α x) h4

  have h6 : HasMFDerivAt (𝓡 m) (𝓡 m) ((φ_β.symm ≫ₕ φ_α) ∘ (φ_α.symm ≫ₕ φ_β)) (φ_α x) ((Dβα x).comp (Dαβ x)) := by
    apply HasMFDerivAt.comp (φ_α x) h2_rw h1

  have h7 : MDifferentiableAt (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) := by
     apply HasMFDerivAt.mdifferentiableAt h6

  have h8 : mfderiv (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) =
            mfderiv (𝓡 m) (𝓡 m) id (φ_α x) := by
            have h1 : mfderivWithin (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) s (φ_α x) =
                      mfderiv (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) := by
                      apply MDifferentiable.mfderivWithin h7 (IsOpen.uniqueMDiffWithinAt (open_image_of_inter_sources m φ_α φ_β) h4)
            have h2 : mfderivWithin (𝓡 m) (𝓡 m) id s (φ_α x) =
                      mfderiv (𝓡 m) (𝓡 m) id (φ_α x) := by
                      apply MDifferentiable.mfderivWithin mdifferentiableAt_id (IsOpen.uniqueMDiffWithinAt (open_image_of_inter_sources m φ_α φ_β) h4)
            calc
                mfderiv (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x) =
                mfderivWithin (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) s (φ_α x) := by
                  apply h1.symm
                _ = mfderivWithin (𝓡 m) (𝓡 m) id s (φ_α x) := by
                  apply h5
                _ = mfderiv (𝓡 m) (𝓡 m) id (φ_α x) := by
                  apply h2

  have h9 : HasMFDerivAt (𝓡 m) (𝓡 m) (↑(φ_β.symm ≫ₕ φ_α) ∘ ↑(φ_α.symm ≫ₕ φ_β)) (φ_α x)
              (mfderiv (𝓡 m) (𝓡 m) ((φ_α ∘ φ_β.symm)  ∘ (φ_β ∘ φ_α.symm)) (φ_α x)) := by
                apply MDifferentiableAt.hasMFDerivAt h7

  have ha : HasMFDerivAt
            (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x)
            (mfderiv (𝓡 m) (𝓡 m) id (φ_α x)) := by
            rw [<-h8]
            exact h9

  have hb : HasMFDerivAt
            (𝓡 m) (𝓡 m) ((↑φ_α ∘ ↑φ_β.symm) ∘ ↑φ_β ∘ ↑φ_α.symm) (φ_α x)
            (ContinuousLinearMap.id ℝ (TangentSpace (𝓡 m) (φ_α x))) := by
            rw [<-mfderiv_id]
            exact ha

  apply hasMFDerivAt_unique hb h6
```

* Log for [2025-01-09 Thu 11:09]


  E                 →L[ℝ] E [⋀^Fin n]→L[ℝ] F
  E →SL[?m.74665] E →L[ℝ] E [⋀^Fin n]→L[ℝ] F

* Log for [2025-01-11 Sat 11:44]

structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] 
  [Group G] [TopologicalGroup G] (P : Type*) [TopologicalSpace P] [FiberBundle G P] 
  (π : P → B) :=
  (action : P → G → P)  -- Free and transitive action of G on each fiber
  (identity : ∀ p : P, action p e = p)  -- Identity element of G acts trivially
  (associativity : ∀ p : P, ∀ g₁ g₂ : G, action (action p g₁) g₂ = action p (g₁ * g₂))  -- Group action is associative
  (free : ∀ p : P, ∀ g : G, action p g = p → g = e)  -- Free action: only identity fixes a point
  (transitive : ∀ b : B, ∀ p₁ p₂ : P, π p₁ = π p₂ → ∃ g : G, action p₁ g = p₂)  -- Transitive action on fibers

structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b -- Free and transitive action of G on each fiber
  free : ∀ b (x : E b), Function.Injective (action b · x) -- Free action
  transitive : ∀ b (x₁ x₂ : E b), ∃ g : G, action b g x₁ = x₂
  -- equivariant :
  --   ∀ b g x, Bundle.TotalSpace.proj ⟨b, action b g x⟩ = Bundle.TotalSpace.proj ⟨b, x⟩

structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b -- Free and transitive action of G on each fiber
  equivariant :
    ∀ b g x, Bundle.TotalSpace.proj (⟨b, action b g x⟩) = Bundle.TotalSpace.proj (⟨b, x⟩) -- Action respects projection
  free : ∀ b (x : E b), Function.Injective (action b · x) -- Free action

structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b -- Free and transitive action of G on each fiber
  equivariant :
    ∀ b g x, Bundle.TotalSpace.proj (⟨b, action b g x⟩) = Bundle.TotalSpace.proj (⟨b, x⟩) -- Action respects projection
  free : ∀ b (x : E b), Function.Injective (action b · x) -- Free action

structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b -- Free and transitive action of G on each fiber
  equivariant :
    ∀ b g x, Bundle.TotalSpace.proj (⟨b, action b g x⟩) = Bundle.TotalSpace.proj (⟨b, x⟩) -- Action respects projection
  free : ∀ b (x : E b), Function.Injective (action b · x) -- Free action


structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b -- Free and transitive action of G on each fiber
  equivariant :
    ∀ b g x, Bundle.TotalSpace.proj ⟨b, action b g x⟩ = Bundle.TotalSpace.proj ⟨b, x⟩ -- Action respects projection
  free : ∀ b (x : E b), Function.Injective (action b · x) -- Free action


structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b -- Free and transitive action of G on each fiber
  equivariant :
    ∀ b g x, Bundle.TotalSpace.proj ⟨b, action b g x⟩ = Bundle.TotalSpace.proj  ⟨b, x⟩ -- Action respects projection
  free : ∀ b (x : E b), Function.Injective (action b · x) -- Free action
  proper : ∀ b, ProperSpace (E b) -- Proper action ensures good quotient properties

* Log for [2025-01-12 Sun 10:35]

variable {B G E : Type*} {E : B → Type*}[TopologicalSpace B] [TopologicalSpace G] [Group G]
  [TopologicalGroup G] [TopologicalSpace (Bundle.TotalSpace G E)]
  [(b : B) → TopologicalSpace (E b)] [FiberBundle G E]


structure PrincipalBundle (B G : Type*) [TopologicalSpace B] [TopologicalSpace G] [Group G] [TopologicalGroup G]
  (E : B → Type*) [∀ b, TopologicalSpace (E b)] [TopologicalSpace (Bundle.TotalSpace G E)] [FiberBundle G E] where
  action : ∀ b, G → E b → E b
  identity : ∀ b x, action b (1 :G) x = x
  associativity : ∀ b g₁ g₂ x, action b (g₁ * g₂) x = action b g₁ (action b g₂ x)

notation:50 g " ⊲[" b "] " x => PrincipalBundle.action b g x

#check ∀ b x, PrincipalBundle.action b (1 :G) x = x
#check ∀ b x, (1 ⊲[b] x) = x
#check ∀ b g₁ g₂ x, PrincipalBundle.action b (g₁ * g₂) x = PrincipalBundle.action b g₁ (PrincipalBundle.action b g₂ x)
#check ∀ b g₁ g₂ x, PrincipalBundle.action b (g₁ * g₂) x = (g₁ ⊲[b] g₂ ⊲[b] x)
#check ∀ b g₁ g₂ x, ((g₁ * g₂) ⊲[b] x) = (g₁ ⊲[b] g₂ ⊲[b] x)

-- example : ∀ b x, PrincipalBundle.action b (1 : G) x = x := sorry
-- example : ∀ b x, (1 ⊲[b] x) = x := sorry

\begin{aligned}
&\text {Let } \triangleright: G \times M \rightarrow M \text { be an action on } M \text {. Define a relation on } M\\
&p \sim q: \Leftrightarrow \exists g \in G: q=g \triangleright p
\end{aligned}

     have h6a : orbitRel G P p p → ∃ g : G, g • p = p := by
      intro h
      exact ⟨1, one_smul _ p⟩

    have h8 : ∃ g : G, g • p = p := Exists.intro 1 h2

    have h9

    have h6 : orbitRel G P p p ↔ ∃ g : G, g • p = p := by

      apply h5

          have h2b :  p = g⁻¹ • q := by
            calc p = (1 : G) • p := by sorry
            _ = (g⁻¹ * g) • p := by sorry
            _ = g⁻¹ • (g • p) := by sorry
            _ = g⁻¹ • q := by sorry
	    
example {G B : Type*} {E : B → Type*} (k n : ℕ)
[TopologicalSpace B]
[ChartedSpace (EuclideanSpace ℝ (Fin n)) B]
[TopologicalSpace G]
[ChartedSpace (EuclideanSpace ℝ (Fin k)) G]
[Group G]
[MulAction G P]
[TopologicalGroup G]
[TopologicalSpace (TotalSpace G E)]
[(b : B) → TopologicalSpace (E b)]
[LieGroup (𝓡 k) G]
[FiberBundle G E] (g g': G) (p q r : P) :
  true := by
    -- Just things we know to be true for an action
    have h1 : g • (g' • p) = (g * g') • p := by apply (mul_smul g g' p).symm
    have h2 : (1 : G) • p = p := by apply one_smul

* Log for [2025-01-15 Wed 11:43]

lemma fg_inv : f ∘ g = id :=
  funext (λ x => by
    have h_fg3 : f (g x) 0 = x 0 := by simp [g, f]
    have h_fg4 : f (g x) 1 = x 1 := by simp [g, f]
    ext i
    match i with
      | Fin.mk 0 _ => exact h_fg3
      | Fin.mk 1 _ => exact h_fg4
    )

lemma gf_inv : g ∘ f = id :=
  funext (λ x => by
    have h_gf1 : g (f x) = x := by simp [f,g]
    exact h_gf1)


def Circle.smuk (x : Circle) (z : Fin 2 → ℝ) : Fin 2 → ℝ :=
  λ i =>  let u := Complex.mk (z 0) (z 1)
         let v := u * x
         if i = 0 then v.re else v.im

* Log for [2025-01-17 Fri 18:13]

  -- have h1 : h • ξ ∈ orbit Circle ξ := mem_orbit _ _
  -- have h2 : ξ ∈ orbit Circle ξ := mem_orbit_self _


* Log for [2025-01-20 Mon 15:16]

ave h13 : h * 1 = h * ((g x ) / (g x)) := by rw [<-h10]
  have h14 : h * ((g x ) / (g x)) = g x / (g x) := h9e
  have h15 : (g x) / (g x) = 1 := h11
  have h16 : h * 1 = g x / (g x) := by
    calc h * 1 = h * ((g x ) / (g x)) := h13
         _  = g x / (g x) := h14
  have h9a : ((g x) / (g x)) * h = (g x) * (h / (g x)) := by
    rw [mul_comm_div]

  have h9c : h * ((g x) / (g x)) = (h / (g x)) * (g x) := by
    rw [mul_comm_div]
  have h9b : h * ((g x) * (g x)⁻¹) = (g x) * (g x)⁻¹ := by rw [h9]

  have h7 : h * (g x) / (g x) = h * (g x) * (g x)⁻¹ := by rw [div_eq_mul_inv]
  have h8a : h * ((g x) * (g x)⁻¹) = h := by rw [DivisionSemiring.mul_inv_cancel (g x) h5, mul_one]
  have h8 : h * ((g x) * (g x)⁻¹) = (g x) * (g x)⁻¹ := by rw [<-mul_assoc, h6]
  have h9 : g x * (g x)⁻¹ = 1 := by rw [DivisionSemiring.mul_inv_cancel (g x) h5]
  have h11 : h * (g x * (g x)⁻¹) = h * 1 := by rw [h8a, mul_one]
  have h12 : h * 1 = 1 := by
    calc h * 1 = h * (g x * (g x)⁻¹) := by rw [<-h11]
         _ = h := by rw [h8a]

  sorry

* Log for [2025-01-22 Wed 07:40]

\psi_{i j}=\phi_j \circ \phi_i^{-1}:\left(U_i \cap U_j\right) \times F \rightarrow\left(U_i \cap U_j\right) \times F

g_{i j}: U_i \cap U_j \rightarrow G \text {, that is, } \psi_{i j}(x, f)=\left(x, g_{i j}(x) \cdot f\right)

* Log for [2025-01-27 Mon 15:28]

Suppose we have two local trivialisations $$\phi_i : \pi^{-1}(U_i)
\longrightarrow U_i \times F$$ and $$\phi_j : \pi^{-1}(U_j)
\longrightarrow U_i \times F$$ then $$p \mapsto (\pi(p),f_i(p))$$ for
some $$f_i : \pi^{-1}(x) \longrightarrow F$$ and correspondingly for
$$j$$.

We have for a fibre $$\pi^{-1}(x)$$, $$f_j \circ f_i^{-1} : F
\longrightarrow F$$ and we suppose that this homeomorphism (or diffeo)
is the left action of an element $$g_{ij}(x)$$, that is, $$f_i(p) =
g_{ij}(x) \triangleright f_j(x)$$ then the bundle is a $$G$$-bundle.

* Log for [2025-01-29 Wed 11:54]

theorem ber : ∀ (i j : ↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)),
              ∀ x ∈ (fun x => univ) i ∩ (fun x => univ) j,
              ∃ (g : (⊥ : Subgroup Circle)), ∀ (v : ℝ),
              GBundleCore.coordChange (self : GBundleCore (⊥ : Subgroup Circle)  (↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)) Circle ℝ)
                                      i j x v = @HSMul.hSMul (⊥ : Subgroup Circle) ℝ ℝ hsMul g v
              := by
    sorry

theorem bir :  GBundleCore.coordChange (self : GBundleCore (⊥ : Subgroup Circle)  (↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)) Circle ℝ) =
              (fun x x x => ⇑(ContinuousLinearMap.id ℝ ℝ)) := by sorry

noncomputable
def foo : GBundleCore (⊥ : Subgroup Circle) (atlas (EuclideanSpace ℝ (Fin 1)) Circle) Circle ℝ :=
  { baseSet := λ _ => univ
    isOpen_baseSet := λ _ => isOpen_univ
    indexAt := λ i => sorry
    mem_baseSet_at := λ x => mem_univ x
    coordChange := λ _ _ _ => ContinuousLinearMap.id ℝ ℝ
    coordChange_self := λ _ _ _ _ => rfl
    continuousOn_coordChange := sorry
    coordChange_comp := λ _ _ _ _ _ _ => rfl
    coordChange_structure_group := by
      have h1 : GBundleCore.coordChange (foo : GBundleCore (⊥ : Subgroup Circle)  (↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)) Circle ℝ) =
              (fun x x x => ⇑(ContinuousLinearMap.id ℝ ℝ)) := by sorry
      -- have h2 :  ∀ (i j : ↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)),
      --   ∀ x ∈ (fun x => univ) i ∩ (fun x => univ) j,
      --   ∃ g, ∀ (v : ℝ), (fun x x x => ⇑(ContinuousLinearMap.id ℝ ℝ)) i j x v = g • v := by sorry
      have ber : ∀ (i j : ↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)),
              ∀ x ∈ (fun x => univ) i ∩ (fun x => univ) j,
              ∃ (g : (⊥ : Subgroup Circle)), ∀ (v : ℝ),
              GBundleCore.coordChange (self : GBundleCore (⊥ : Subgroup Circle)  (↑(atlas (EuclideanSpace ℝ (Fin 1)) Circle)) Circle ℝ)
                                      i j x v = @HSMul.hSMul (⊥ : Subgroup Circle) ℝ ℝ hsMul g v
              := by sorry
      exact bar foo
    }

* Log for [2025-02-05 Wed 19:53]

https://people.ucsc.edu/~rmont/classes/ManifoldsII/Solutions/209hw2.pdf

* Log for [2025-02-06 Thu 17:24]

nstance : HSMul (orthogonalGroup (Fin 1) ℝ) ℝ ℝ where
  hSMul := fun g r => g.1 0 0 * r

instance : MulAction (orthogonalGroup (Fin 1) ℝ) ℝ where
  smul := fun g x => (g.1 0 0) * x
  one_smul := fun x => by
    have h1 : (1 : orthogonalGroup (Fin 1) ℝ) • x = (1 : orthogonalGroup (Fin 1) ℝ).1 0 0 * x := by
      rfl
    have h2 : (1 : orthogonalGroup (Fin 1) ℝ).1 0 0 * x = x := by simp
    have h3 : (1 : orthogonalGroup (Fin 1) ℝ) • x = x := by rw [h1, h2]
    exact h3
  mul_smul := fun g h x => by
    have h2 : g • (h • x) = g • (h • x) := rfl
    have h3 : g • (h • x) = (g.1 0 0) * (h • x) := by rfl
    have h4 : (g.1 0 0) * (h • x) = (g.1 0 0) * ((h.1 0 0) * x) := by rfl
    have h5 : (g.1 0 0) * ((h.1 0 0) * x) = ((g.1 0 0) * (h.1 0 0)) * x := by simp only [mul_assoc]
    have h6 : ((g.1 0 0) * (h.1 0 0)) * x = (g * h).1 0 0 * x := by
      simp only [Matrix.mul_apply, Matrix.one_apply, Matrix.coe_one, Matrix.coe_zero]
      exact rfl

    rw [h3, h4, h5, h6]
  -- mul_smul := fun g h x => by
  --  have h2 : g • (h • x) = g • (h • x) := rfl
  --  have h3 : g • (h • x) = (g.1 0 0) * (h • x) := by rfl
  --  have h4 : (g.1 0 0) * (h • x) = (g.1 0 0) * ((h.1 0 0) * x) := by rfl
  --  have h5 : (g.1 0 0) * ((h.1 0 0) * x) = ((g.1 0 0) * (h.1 0 0)) * x := by sorry
  --  have h6 : ((g.1 0 0) * (h.1 0 0)) * x = (g * h).1 0 0 := by sorry
  --  sorry

noncomputable
instance : MulAction (GeneralLinearGroup  ℝ (Fin n -> ℝ)) (Fin n -> ℝ)  where
  smul := λ g x => g.toLinearEquiv x
  one_smul := λ x => by
    have h1 :  (1 : GeneralLinearGroup ℝ (Fin n → ℝ)) • x = x := by rfl
    exact h1
  mul_smul := λ f g x => by
    have h1 : (f * g) • x = (f * g).toLinearEquiv x := by rfl
    have h2: (f * g).toLinearEquiv x = f.toLinearEquiv (g.toLinearEquiv x) := by rfl
    have h3 : f.toLinearEquiv (g.toLinearEquiv x) = f.toLinearEquiv (g • x) := rfl
    have h4 : f.toLinearEquiv (g • x) = f • (g • x) := rfl
    rw [h1, h2, h3, h4]

* Log for [2025-02-07 Fri 10:49]

    -- have h1 :  (1 : GeneralLinearGroup ℝ (Fin n → ℝ)) • x = x := by rfl
    -- have h2 : UnitaryGroup.toGL (1 : unitaryGroup (Fin n) ℝ) = (1 : GeneralLinearGroup ℝ (Fin n → ℝ)) := by simp
    -- have h3 : (UnitaryGroup.toGL (1 : unitaryGroup (Fin n) ℝ)) • x = x := by rfl

 mul_smul := λ f g x => by
    have h1 : ((UnitaryGroup.toGL g) * (UnitaryGroup.toGL f)) • x = (UnitaryGroup.toGL g) • (UnitaryGroup.toGL f) • x := by rfl
    have h1 : (UnitaryGroup.toGL (f * g)).toLinearEquiv x = (UnitaryGroup.toGL f * UnitaryGroup.toGL g).toLinearEquiv x := by
      -- Use the group homomorphism property of toGL
      apply Subtype.ext
      simp
    rw [h1]


instance : MulAction (orthogonalGroup (Fin n) ℝ) (Fin n -> ℝ) where
  smul := λ g x => (UnitaryGroup.toGL g).toLinearEquiv x
  one_smul := λ x => by
    have h1 : (1 : GeneralLinearGroup ℝ (Fin n → ℝ)) • x = x := by rfl
    exact sorry
  mul_smul := λ f g x => by
    have h1 : (UnitaryGroup.toGL (f * g)).toLinearEquiv x = (UnitaryGroup.toGL f * UnitaryGroup.toGL g).toLinearEquiv x := by rfl
    rw [h1]

 let foo := λ r => by
  have h4 : exp (r * I) ∈ Submonoid.unitSphere ℂ ↔ Complex.abs (exp r)= 1 := mem_circle_iff_abs
  have h3 : Circle.exp.toFun r ∈ Circle := rfl
  have h1 : abs (exp (r * I)) = 1 := abs_exp_ofReal_mul_I r
  have h1 : abs (cexp (↑r * I)) = 1 := Complex.abs_exp_ofReal_mul_I r

  have h2 : 1 ∈ Submonoid.unitSphere ℂ := sorry
  exact (sorry : exp (r * I) ∈ Submonoid.unitSphere ℂ)


* Log for [2025-02-08 Sat 13:00]

theorem bar (r : ℝ) : exp (r * I) ∈ Submonoid.unitSphere ℂ := by
  have h1 : abs (exp (r * I)) = 1 := abs_exp_ofReal_mul_I r
  have h2 : exp (r * I) ∈ Metric.sphere 0 1 ↔ ‖exp (r * I)‖ = 1 := mem_sphere_zero_iff_norm
  have h3 : ‖exp (r * I)‖ = abs (exp (r * I)) := rfl
  have h4 : Metric.sphere (0 : ℂ) 1 = Submonoid.unitSphere ℂ := by rfl
  have h5 : ‖exp (r * I)‖ = 1 := by
    rw [h3, h1]
  have h6 : exp (r * I) ∈ Metric.sphere 0 1 := h2.2 h5
  have h7 : exp (r * I) ∈ Submonoid.unitSphere ℂ := h6
  exact h7

* Log for [2025-02-09 Sun 12:00]

theorem baz (r : ℝ) (hr : r ∈ Ioo 0 (2 * Real.pi)) :
  ⟨exp (r * I), exp_mem_unitSphere r⟩ ∈ {z : S1 | arg z.val ∈ Ioo 0 (2 * Real.pi)} := by
    let z : S1 := ⟨exp (r * I), exp_mem_unitSphere r⟩
    have hx : 0 < r := hr.1
    have hy : r < 2 * Real.pi := hr.2
    have bik : arg (exp (r * I)) = toIocMod (mul_pos two_pos Real.pi_pos) (-2 * Real.pi) r
    have h_val : z.val = exp (r * I) := rfl
    have h_prp : exp (r * I) ∈ Submonoid.unitSphere ℂ := z.property
    have h_arg : arg z.val = arg (exp (r * I)) := rfl
    have h_abs : abs z.val = abs (exp (r * I)) := rfl
    have bik : arg (exp (r * I)) = toIocMod (mul_pos two_pos Real.pi_pos) (-2 * Real.pi) r
    have h_arg_eq_r : arg (exp (r * I)) = r := sorry
    have ha : 0 < arg (exp (r * I)) := sorry
    have hb : arg (exp (r * I)) < 2 * Real.pi := sorry
    exact ⟨ha, hb⟩


* Log for [2025-02-11 Tue 18:16]

noncomputable
def chart_at_S1_excluding_minus_1 : PartialHomeomorph S1 ℝ :=
{
  toFun := λ z => arg z.val,
  invFun := λ r => ⟨exp (r * Complex.I), exp_mem_unitSphere r⟩,
  source := {z : S1 | arg z.val ∈ Ioo (-Real.pi) (Real.pi)},
  target := Ioo (-Real.pi) (Real.pi),
  map_source' := λ z hz => hz,
  map_target' := λ r hr => by
    have h1 : (exp (r * I)).arg = r := arg_exp_of_range r hr
    have h2a : (-Real.pi) < r := hr.1
    have h2b : r < Real.pi := hr.2
    have h3a : (-Real.pi) < (exp (r * I)).arg := by
      rw [h1]
      exact h2a
    have h3b : (exp (r * I)).arg < (Real.pi) := by
      rw [h1]
      exact h2b
    exact ⟨(h3a : (-Real.pi) < (exp (r * I)).arg), (h3b : (exp (r * I)).arg < (Real.pi))⟩,
  left_inv' := λ z hz => by
    have h0 : (Complex.abs z.val) * exp ((z.val).arg * I) = z.val := by exact abs_mul_exp_arg_mul_I z.val
    have h4 : z.val ∈ Submonoid.unitSphere ℂ := by exact z.prop
    have h5 : z.val ∈ Metric.sphere 0 1 ↔ ‖z.val‖ = 1 := mem_sphere_zero_iff_norm
    have h7 : z.val ∈ Metric.sphere 0 1 := h4
    have h6 : ‖z.val‖ = 1 := by rwa [h5] at h7
    have h8 : ‖z.val‖ * exp ((z.val).arg * I) = z.val := by exact abs_mul_exp_arg_mul_I z.val
    have h9 : z.val = exp ((z.val).arg * I) := by
      calc z.val = ‖z.val‖ * exp ((z.val).arg * I) := by rw [h8]
                _ = (1 : ℝ) *  exp ((z.val).arg * I) := by rw [h6]
                _ = (1 : ℂ) * exp ((z.val).arg * I) := by norm_cast
                _ = exp ((z.val).arg * I) := by rw [one_mul]
    have h3 : (fun r => ⟨exp (r * I), by exact exp_mem_unitSphere r⟩) (z.val).arg = z := by
      apply Subtype.ext
      exact h9.symm
    exact h3
  right_inv' := λ r hr => by
   have h1 : arg (exp (r * I)) = r := arg_exp_of_range r hr
   exact h1
  open_source := by
    -- have h1 : ContinuousOn sorry z := by exact sorry
    -- have h2 : true := by exact ContinuousAt_arg sorry
    exact sorry,

  open_target := isOpen_Ioo,
  continuousOn_toFun  := (sorry : (ContinuousOn (λ z => arg z.val)) {z : S1 | arg z.val ∈ Ioo (-Real.pi) (Real.pi)}),
  continuousOn_invFun := sorry
}


$$
V=S^1 \backslash\{-1\}=\mathbb{R} / \mathbb{Z} \backslash\left\{\frac{1}{2}\right\}, \phi_2: \pi^{-1}(V) \rightarrow V \times \mathbb{R} \text { by }(x, y) \mapsto \begin{cases}(x, y) & 0 \leq x<\frac{1}{2} \\ (x-1,-y) & \frac{1}{2}<x \leq 1\end{cases}
$$

Fair point.

Let $$\sim$$ be the equivalence relation on $$[0,1] \times \mathbb{R}$$ defined by $$(0, y) \sim(1, -y)$$ and the Mobius strip be as usual be $$M=[0,1] \times \mathbb{R} /\sim$$.
Let $$\pi(x, y) = x$$ be the projection map $$\pi : M \rightarrow \mathbb{S}^1$$.

We can define a local trivialization $$\phi_V$$ on $$\pi^{-1}(V)=\pi^{-1}(S^1 \backslash\{\pi\})$$:

$$
\phi_V: \pi^{-1}(V) \rightarrow V \times \mathbb{R} \text { by }(x, y) \mapsto \begin{cases}(x, y) & 0 \leq x<\frac{1}{2} \\ (x-1,-y) & \frac{1}{2}<x \leq 1\end{cases}
$$

We only need check that this map is well defined on $$[(0,y)]$$ as all other equivalence classes are just a single element. For $$(0,y), (1, -) \in [(0,y)]$$:

$$$
\phi_V(0,y) = (0,y) = \phi_V(1, -y)
$$

To expreess that this is a G-bundle in Lean, we previously invented:

```Lean4
structure GBundleCore (ι : Type*) (B : Type*) [TopologicalSpace B] (F : Type*)
    [TopologicalSpace F] (G : Type*) [Group G] [MulAction G F] where
  baseSet : ι → Set B
  isOpen_baseSet : ∀ i, IsOpen (baseSet i)
  indexAt : B → ι
  mem_baseSet_at : ∀ x, x ∈ baseSet (indexAt x)
  coordChange : ι → ι → B → F → F
  coordChange_self : ∀ i, ∀ x ∈ baseSet i, ∀ v, coordChange i i x v = v
  continuousOn_coordChange : ∀ i j,
    ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)
  coordChange_comp : ∀ i j k, ∀ x ∈ baseSet i ∩ baseSet j ∩ baseSet k, ∀ v,
    (coordChange j k x) (coordChange i j x v) = coordChange i k x v
  coordChange_structure_group : ∀ i j, ∀ x ∈ baseSet i ∩ baseSet j, ∃ g : G, ∀ v : F, coordChange i j x v = g • v
```

In particular we `indexAt` which gives a chart at a point in the base space of the bundle. Thus I started creating an atlas for the circle with two charts (as has been suggested). This proved trickier than anticipated and I was showing what I had so far for just one of the (two) charts.

theorem t3 : ∀ (y : ℝ), {x : Circle | x ≠ (Circle.exp y : Circle)} =
                             (chartAt (EuclideanSpace ℝ (Fin 1)) (Circle.exp y : Circle)).source := by
  intro y
  let v : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 :=
    ⟨![Real.cos y, Real.sin y], by
      simp [Metric.sphere, EuclideanSpace.norm_eq, Fin.sum_univ_succ, Real.cos_sq_add_sin_sq]⟩
  have h0 : (stereographic' 1 v).source = {v}ᶜ := stereographic'_source v
  have h1 : (chartAt (EuclideanSpace ℝ (Fin 1)) v).source = (stereographic' 1 (-v)).source := rfl
  have h2 : (chartAt (EuclideanSpace ℝ (Fin 1)) v).source = {v}ᶜ := sorry

  have ha : x ∈ {v}ᶜ ↔ x ≠ v := Set.mem_compl_singleton_iff
  have hv_notin : v ∉ (stereographic' 1 v).source := by
    rw [stereographic'_source]
    exact ha.mpr (ne.refl v)

  have h0 : (stereographic' 1 v).source = {v}ᶜ := stereographic'_source v
  have ha : v ∈ {(-v)}ᶜ ↔ v ≠ (-v) := Set.mem_compl_singleton_iff

  have hv_notin : v ∉ (stereographic' 1 v).source := by
    rw [stereographic'_source]
    exact Set.not_mem_compl_singleton v
    -- exact (sorry : v ∉ {v}ᶜ)
  sorry

-- have ha : ∀ x, x ∈ (stereographic' 1 v).source <-> x ≠ v := sorry
-- have h2 : {x | x ≠ v}ᶜ = {v} := Set.compl_ne_eq_singleton v
-- have h1 : {v}ᶜ = {x | x ∉ {v}} := Set.compl_def {v}


  have hf : ‖(((z.val.re) : ℝ), ((z.val.im) : ℝ))‖ = 1 := sorry
  -- have he : b ∈ Metric.sphere 0 1 ↔ ‖b‖ = 1  := mem_sphere_iff_norm

* Log for [2025-02-14 Fri 12:15]

#check ![(1 : ℝ), (0 : ℝ)] ∈  (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1)
#check Circle.exp 0
#check Complex.norm_eq_abs
#check ‖(![(1 : ℝ), (0 : ℝ)] : (Fin 2 -> ℝ))‖

example : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 = {x | ∑ i : Fin 2, x i ^ 2 = 1 ^ 2} := EuclideanSpace.sphere_zero_eq 1 sorry

#check le_of_lt Real.zero_lt_one

noncomputable
def foof : ℝ -> ℝ -> ℝ
  | x, a => if x > 0 then a else -a

theorem fooff (x : ℝ) (a : ℝ) : foof x (foof x a) = a := by
  by_cases h : x > 0
  case pos =>
    simp [foof, h]
  case neg =>
    simp [foof, h]

    
noncomputable
def foof : ℝ -> ℝ -> ℝ
  | x, a => if x > 0 then a else -a

theorem fooff (x : ℝ) (a : ℝ) : foof x (foof x a) = a := by
  by_cases h : x > 0
  case pos =>
    simp [foof, h]
  case neg =>
    simp [foof, h]

* Log for [2025-02-17 Mon 08:38]

#synth ChartedSpace (EuclideanSpace ℝ (Fin 1)) Circle
#check (ChartedSpace.chartAt _).source
#check (ChartedSpace.chartAt : Circle → PartialHomeomorph Circle (EuclideanSpace ℝ (Fin 1)))
#check U.source
#check finrank_real_complex_fact'
#check Complex

theorem set_eq_mem {A B : Set α} {x : α} (h1 : A = B) (h2 : x ∈ A) : x ∈ B := by
  rw [h1] at h2
  exact h2

theorem bir2 : y.val ∈ { a : EuclideanSpace ℝ (Fin 2) | (a 0)^2 + (a 1)^2 = 1 ∧ (a 0, a 1) ≠ (x 0, x 1) } -> y ∈ { x | x ≠ xh } := by
  intro h
  have h1 : y.val 0 ^ 2 + y.val 1 ^ 2 = 1 ∧ (y.val 0, y.val 1) ≠ (x 0, x 1) := by
    rw [Set.mem_setOf_eq] at h
    exact h
  have h2 : y.val 0 ^ 2 + y.val 1 ^ 2 = 1 := h1.left
  have h3 : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 = {x | ∑ i : Fin 2, x i ^ 2 = 1 ^ 2} := by
   exact EuclideanSpace.sphere_zero_eq 1 (le_of_lt Real.zero_lt_one)
  have h5 : y.val ∈ Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 := bor1 h2
  have h4 : ⟨y, h5⟩ ∈ { x | x ≠ xh } := sorry
  exact h4

* Log for [2025-02-19 Wed 08:49]

theorem bir : { x | x ≠ xh } = { a : EuclideanSpace ℝ (Fin 2) | (a 0)^2 + (a 1)^2 = 1 ∧ (a 0, a 1) ≠ (x 0, x 1) } := sorry

How is that type correct?


theorem bir2 : y.val ∈ { a : EuclideanSpace ℝ (Fin 2) | (a 0)^2 + (a 1)^2 = 1 ∧ (a 0, a 1) ≠ (x 0, x 1) } → y ∈ { x | x ≠ xh } := by
  intro h
  rw [Set.mem_setOf_eq] at h
  obtain ⟨h1, h2⟩ := h
  have h5 : y.val ∈ Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 := bor1 h1
  have h6 : y.val ≠ xh.val := fun h' => h2 (congr_arg (fun z => (z 0, z 1)) h')
  exact fun h' => h6 (congr_arg Subtype.val h')

variable {y : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1}
variable {xh : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1}

theorem bir3 : ∀ xh, y.val ∈ { a : EuclideanSpace ℝ (Fin 2) | (a 0)^2 + (a 1)^2 = 1 ∧ (a 0, a 1) ≠ (xh.val 0, xh.val 1) } → y ∈ { x | x ≠ xh } := by
  intro _ h
  rw [Set.mem_setOf_eq] at g
  obtain ⟨h1, h2⟩ := h
  have h5 : y.val ∈ Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 := bor1 h1
  have h6 : y.val ≠ xh.val := fun h' => h2 (congr_arg (fun z => (z 0, z 1)) h')
  exact fun h' => h6 (congr_arg Subtype.val h')

* Log for [2025-02-20 Thu 10:59]

def PR := Subtype (λ (x : ℝ) => x > 0)

instance urk : SProd (Set PR) (Set ℝ) (Set (PR × ℝ)) where
  sprod := sorry

#check SProd {x : PR | x.val > 1} {y : ℝ | y < 2}

example : Set (PR × ℝ) := {x | x.val > 1} ×ˢ {y | y < 2}

def hh : PR ×ˢ ℝ -> ℝ := λ (x, y) => y

#check SProd PR ℝ

 have h1 : Set.EqOn (λ p => MyCoordChange 0 1 p.1 p.2) fn1 ({ x : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 | x.val 1 > 0 } ×ˢ (univ : Set (EuclideanSpace ℝ (Fin 1)))) := by
   intro a h
   have h1 : fn1 a = a.2 := rfl
   have h2 : MyCoordChange 0 1 a.1 a.2 = if (a.1.val 1) > 0 then a.2 else -a.2 := rfl
   have h3 : a ∈ {x | x.val 1 > 0} ×ˢ univ := h
   exact sorry

  have h1 : Set.EqOn (λ p => MyCoordChange 0 1 p.1 p.2) fn1
            ({ x : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 | x.val 1 > 0 } ×ˢ (univ : Set (EuclideanSpace ℝ (Fin 1)))) := by
    intro a ha
    simp only [MyCoordChange]
    have h3 : a ∈ {x | x.val 1 > 0} ×ˢ univ := ha
    have h1 : fn1 a = a.2 := rfl
    rw [h1]
    have h4 : a.1.val 1 > 0 := h3.1
    rw [if_pos h4] 

type mismatch
  foo
has type
  {x | x ∈ s ∧ x > 0 ∨ x ∈ s ∧ x < 0} ∪ {x | x ∈ s ∧ x = 0} = {x | (x ∈ s ∧ x > 0 ∨ x ∈ s ∧ x < 0) ∨ x ∈ s ∧ x = 0} : Prop
but is expected to have type
  {x | x ∈ s ∧ x > 0 ∨ x ∈ s ∧ x < 0} ∪ {x | x ∈ s ∧ x = 0} = {x | (x ∈ s ∧ x > 0 ∨ x ∈ s ∧ x < 0) ∨ x = 0} : PropLean

* Log for [2025-02-25 Tue 07:56]

theorem faa {a : ℝ} (h : a < 0 ∨ a = 0 ∨ a > 0) : true := by
    cases h with
      | inl hl => exact -1
      | inr hr => cases hr with
                    | inl hrl => exact 0
                    | inr hrr => exact 1


variable {α : Type} -- Declare a type α for generality
variable (s : Set α) -- s is a set of elements of type α
variable (a b : α) -- a and b are elements of type α

theorem fff a b (h1 : a = b) (h2 : b ∈ s) : a ∈ s :=  by
  rw [h1]
  exact h2



example (h : x ∈ {x : ℝ | x ≤ 0}) : x ∉ {x : ℝ | x > 0} := by
  intro k
  have h1 : x > 0 := k
  have h2 : ¬ (x > 0) := not_lt_of_le h
  contradiction

theorem fff : {x : ℝ | x ≤ 0} ∩ {x | x > 0} = ∅ := by
  have hp : {x : ℝ | x > 0}ᶜ = {x : ℝ | x ≤ 0} := by ext x; simp
  have hq : {x : ℝ | x > 0}ᶜ ∩ {x | x > 0} = ∅ := Set.compl_inter_self {x : ℝ | x > 0}
  rw [hp] at hq
  exact hq

example : {x : ℝ | x ≤ 0} ∩ {x | x > 0} = ∅ := by
  have h1 : {x : ℝ | x > 0}ᶜ = {x : ℝ | x ≤ 0} := by ext x; simp
  have h2 : {x : ℝ | x > 0}ᶜ ∩ {x | x > 0} = ∅ := Set.compl_inter_self {x : ℝ | x > 0}
  have h3 : {x : ℝ | x ≤ 0} ∩ {x | x > 0} = {x : ℝ | x > 0}ᶜ ∩ {x | x > 0} := by rw [h1]
  have h4 : {x: ℝ | x ≤ 0} ∩ {x | x > 0} = ∅ :=
    calc
      {x : ℝ | x ≤ 0} ∩ {x | x > 0} = {x : ℝ | x > 0}ᶜ ∩ {x | x > 0} := h3
      _ = ∅ := h2
  exact h4

example : {x : ℝ | x ≤ 0} ∩ {x : ℝ | x > 0} = ∅ := by
  ext x
  have h1 : x > 0 := sorry
  have h2 : ¬ (x > 0) := not_lt_of_le sorry
  contradiction


 lemma preimage_nonpos (p : ℝ → ℝ) (hp : ∀ x, p x = if x > 0 then 1 else -1) (t : Set ℝ) (h : 1 ∉ t ∧ -1 ∈ t) :
  p ⁻¹' t = {x | x ≤ 0} := by
  ext x
  -- simp only [Set.mem_preimage, hp]
  simp [hp]
  -- intro hx
  -- exact (sorry : x ∈ p ⁻¹' t ↔ x ∈ {x | x ≤ 0})
  -- exact (sorry : (if x > 0 then 1 else -1) ∈ t ↔ x ∈ {x | x ≤ 0})
  exact (sorry : (if 0 < x then 1 else -1) ∈ t ↔ x ≤ 0)

* Log for [2025-03-01 Sat 08:54]

  have h3 : f ⁻¹' u ∩ s ∪ f ⁻¹' u ∩ t= f ⁻¹' u ∩ (s ∪ t) := by rw [<-Set.inter_union_distrib_left]
  have h4 : s ∩ (f ⁻¹' u) = (f ⁻¹' u) ∩ s := by rw [inter_comm]

* Log for [2025-03-05 Wed 10:47]

theorem u01 : ContinuousOn (λ p => MyCoordChange 0 1 p.1 p.2) ((chart_excluding_minus_1.source ∩ chart_excluding_1.source) ×ˢ univ) := by
  let f : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1)
  | (x, α) =>if (x.val 1) > 0 then α else -α
  have h1 : (chart_excluding_minus_1.source ∩ chart_excluding_1.source) = { x | x.val 1 > 0 } ∪ { x | x.val 1 < 0 } := SulSource
  have hz : ContinuousOn f s := by
    apply continuous_snd.continuousOn.congr
    -- EqOn f Prod.snd s
    intro x hx
    -- ⊢ f x = x.2
    dsimp [f, s] at hx -- ⊢
    -- (if ↑x.1 1 > 0 then x.2 else -x.2) = x.2
    -- rw [if_pos hx]
    exact if_pos hx
  have hz' : ContinuousOn f' s := by
    exact hz
  have hz : ContinuousOn f s := by
    apply  ContinuousOn.congr (Continuous.continuousOn continuous_snd) -- continuous_snd.continuousOn.congr
    intro x hx
    dsimp [f, s] at hx
    exact if_pos hx
  sorry

example : ContinuousOn MyCoordChange01' s' := by
  have h0 : IsOpen s' := by
    let π : ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) → ℝ :=
      λ x => x.1.val 1
    have hz : Continuous (Prod.fst : ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) -> (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1)) := continuous_fst
    have hy : (Prod.fst : ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) -> (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1)) =
              fun (x : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) => x.1 := sorry
    have hx : Continuous (fun (x : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) => x.1.val) := by
      rw [hy] at hz
      exact sorry

    have h_cont : Continuous π :=
      (Continuous.comp (continuous_apply 1) hx)

    have h0z : Continuous fun (x : ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1))) ↦ x.1.val 1 := sorry
    have h0a : IsOpen s':= isOpen_lt continuous_const h0z
    exact sorry
  have h2 : ContinuousOn MyCoordChange01' s' ↔ ∀ (t : Set  (EuclideanSpace ℝ (Fin 1))), IsOpen t → IsOpen (s' ∩ MyCoordChange01' ⁻¹' t) := continuousOn_open_iff h0
  have h3 : ∀ (t : Set  (EuclideanSpace ℝ (Fin 1))), IsOpen t → IsOpen (s' ∩ MyCoordChange01' ⁻¹' t) := sorry
  have h4 : ContinuousOn MyCoordChange01' s' := h2.mpr h3
  exact sorry

example
  {f : C(Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1, C(EuclideanSpace ℝ (Fin 1), EuclideanSpace ℝ (Fin 1)))}
  {a : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)} :
   f.uncurry a = uncurry (fun x y ↦ (f x) y) a := ContinuousMap.uncurry_apply f a

#check continuous_snd.continuousOn.congr                           -- EqOn f Prod.snd s → ContinuousOn f s
#check ContinuousOn.congr (Continuous.continuousOn continuous_snd) -- EqOn ?m.199439 Prod.snd ?m.199448 → ContinuousOn ?m.199439 ?m.199448
#check EqOn
/-- Two functions `f₁ f₂ : α → β` are equal on `s` if `f₁ x = f₂ x` for all `x ∈ s`. -/
-- def EqOn (f₁ f₂ : α → β) (s : Set α) : Prop := ∀ ⦃x⦄, x ∈ s → f₁ x = f₂ x

noncomputable
def ff : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1)
  | (x, α) =>if (x.val 1) > 0 then α else -α

noncomputable
def ff' :=  (λ (p : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) => MyCoordChange 0 1 p.1 p.2)

noncomputable
def ff : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1)
  | (x, α) =>if (x.val 1) > 0 then α else -α

noncomputable
def ff' :=  (λ (p : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) => MyCoordChange 0 1 p.1 p.2)

example : ff = ff' := by
  ext p
  have h1 : ff' p = MyCoordChange 0 1 p.1 p.2 := rfl
  have h2 : MyCoordChange 0 1 p.1 p.2 = if (p.1.val 1) > 0 then p.2 else -p.2 := rfl
  have h3 : ff p = if (p.1.val 1) > 0 then p.2 else -p.2 := rfl
  rw [h1, h2, h3]

-- noncomputable
-- def t := { x : ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) ×ˢ (univ : Set (EuclideanSpace ℝ (Fin 1)))) | x.val.1 1 > 0 } ∪
--          { x : ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) ×ˢ (univ : Set (EuclideanSpace ℝ (Fin 1)))) | x.val.1 1 < 0 }

-- #check λ (x : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) ×ˢ (univ : Set (EuclideanSpace ℝ (Fin 1)))) => (x.val.1 1 > 0)

-- noncomputable
-- def MyCoordChange01' : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1)
--   | (x, α) =>if (x.val 1) > 0 then α else -α

-- def s' : Set ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) := { x | 0 < x.1.val 1 }

-- def s : Set ((Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) := { x | 0 < x.1.val 1 }

-- #check chart_excluding_minus_1.source
-- open Topology

-- #check Continuous.uncurry_right
-- #check Continuous.uncurry_left

open Function

theorem my_Continuous.uncurry_left.{u, v, u_1} {X : Type u} {Y : Type v} {Z : Type u_1} [TopologicalSpace X] [TopologicalSpace Y]
  [TopologicalSpace Z] {f : X → Y → Z} (x : X) (h : Continuous (Function.uncurry f)) : Continuous (f x) := h.comp (Continuous.Prod.mk _)

variables {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]
variables {a : Set X} {b : Set Y}

-- Theorem: if a is open in X and b is open in Y, then a × b is open in X × Y
example (ha : IsOpen a) (hb : IsOpen b) : IsOpen (a ×ˢ b) := ha.prod hb

open Set

example : IsOpen (univ : Set X) := isOpen_univ
example : IsOpen (Set.univ : Set X) := isOpen_univ

-- continuousOn_coordChange : ∀ i j,
--   ContinuousOn (fun p : B × F => coordChange i j p.1 p.2) ((baseSet i ∩ baseSet j) ×ˢ univ)

#synth LocallyCompactSpace (EuclideanSpace ℝ (Fin 1))

#check ContinuousMap.uncurry_apply
#check ContinuousMap.continuous_uncurry_of_continuous

example
  {f : C(Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1, C(EuclideanSpace ℝ (Fin 1), EuclideanSpace ℝ (Fin 1)))} :
  Continuous (λ (x : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) => (f x.1) x.2) := by
  have h1 : Continuous (uncurry fun x y ↦ (f x) y) := ContinuousMap.continuous_uncurry_of_continuous f
  have h2 : (uncurry fun x y ↦ (f x) y) = (λ (x : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1)) => (f x.1) x.2) := by
    rfl
  rw [h2] at h1
  exact h1

#check continuousOn_open_iff

-- noncomputable
-- def MyCoordChange01 : (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) → EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1)
--       | x, α => if (x.val 1) > 0 then α else -α

-- noncomputable
-- def MyCoordChange01'': (Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) × EuclideanSpace ℝ (Fin 1) → EuclideanSpace ℝ (Fin 1) := Function.uncurry (MyCoordChange01)


type mismatch
  t01
has type
  ContinuousOn (fun p ↦ MyCoordChange 0 1 p.1 p.2) ((chart_excluding_minus_1.source ∩ chart_excluding_1.source) ×ˢ univ) : Prop
  ContinuousOn (fun p ↦ MyCoordChange 0 1 p.1 p.2) ((chart_excluding_1.source ∩ chart_excluding_minus_1.source) ×ˢ univ) : Prop
but is expected to have type


  have h1 : (stereographic' 1 xh).source = {xh}ᶜ := stereographic'_source xh
  have h2 : {xh}ᶜ = { x | x ≠ xh } := rfl
  have h3: (stereographic' 1 xh).source = {x | x ≠ xh} := by
    rw [<-h1] at h2
    exact h2
  have h4 : (chartAt (EuclideanSpace ℝ (Fin 1)) y).source = (stereographic' 1 (-y)).source := rfl
  have h5 : (stereographic' 1 (-y)).source = {-y}ᶜ := stereographic'_source (-y)
  have h6 : {-y}ᶜ = { x | x ≠ -y } := rfl


    apply Iff.intro
  . intro hy
    obtain ⟨hy1, hy2⟩ := hy
    rw [chartAt_source] at hy1 hy2
    have hfii : y ∈ (stereographic' 1 (-⟨x, h⟩)).source:= hy1
    have aa : (stereographic' 1 xh).source = {x | x ≠ xh} := by
      rw [<-h1] at h2
      exact h2
    have hfoo : y ∈ { x | x ≠ xh } := by
      rw [aa] at hfii
      exact sorry
    have hfuu : y.val 1 ≠ 0 := sorry
    exact hfuu.symm
  . intro hy
    sorry

* Log for [2025-03-06 Thu 08:39]

have foo : y.val ∈ Metric.sphere 0 1 := y.prop
    have bar : xh.val ∈ Metric.sphere 0 1 := xh.prop
    have baz : xh.val = y.val := sorry
    have boz : ⟨x, h⟩ = xh := rfl
    have urk : xh = y := by
      exact congr_fun (congr_arg (λ a => a) baz) sorry
      have val_eq : xh.val = y.val := baz
      exact congr_arg (λ a => a) val_eq

chart_excluding_minus_1.source ∩ chart_excluding_1.source = { x | x ≠ -xh } ∩ { x | x ≠ -ug }

{ x : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 | x.val 1 > 0 } ∪ { x | x.val 1 < 0 } = { x | x.val 1 = 0 }ᶜ

{ x | x ≠ -xh } ∩ { x | x ≠ -ug } = { -xh, -ug }ᶜ

{ x | x.val 1 = 0 } = { -xh, -ug }


chart_excluding_minus_1.source ∩ chart_excluding_1.source = { x | x ≠ -xh } ∩ { x | x ≠ -ug }
                                                          =  { -xh, -ug }ᶜ
							  = { x | x.val 1 = 0 }ᶜ
							  = { x : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 | x.val 1 > 0 } ∪ { x | x.val 1 < 0 }

 chart_excluding_minus_1.source ∩ chart_excluding_1.source = {x | ↑x 1 > 0} ∪ {x | ↑x 1 < 0}


 have foo1 : xh.val = x := rfl
    have foo1a : xh.val 0 = 1 := rfl
    have foo1b : xh.val 1 = 0 := rfl
    have foo1c : xh.val ∈ Metric.sphere 0 1 := xh.prop
    have bar1a : y.val 0 = 1 := sorry
    have bar1b : y.val 1 = 0 := sorry
    have bar1c : y.val ∈ Metric.sphere 0 1 := sorry
    have baz1a : y.val = xh.val := sorry
    have baz : y = xh :=
     cases eq with baz1a
     exact sorry

variable {aaa : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1}
variable {bbb : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1}

example (h : aaa.val = bbb.val) : aaa = bbb := by
  obtain ⟨x₁, h₁⟩ := aaa
  obtain ⟨x₂, h₂⟩ := bbb
  congr


have foo : y.val = ![1, 0] -> y = xh := by
      intro a
      let fff : EuclideanSpace ℝ (Fin 2) → (Fin (Nat.succ 1) → ℝ) := λ v i => v i
      let ggg : (Fin (Nat.succ 1) → ℝ) → EuclideanSpace ℝ (Fin 2) := λ h => h
      obtain ⟨x₁, h₁⟩ := y
      have haa : x₁ = ![1, 0] := a
      have h5 : xh = ((⟨x, h⟩ :  Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 )) := rfl
      obtain ⟨x2, hh2⟩ := xh
      have hz0 : x 0 = 1 := rfl
      have hz1 : x 1 = 0 := rfl
      have hy0 : x2 0 = 1 := by
        exact 

      have hy0 : x2 0 = 1 := sorry
      

      have ha₂ : x2 = ![1, 0] := sorry
      have h3 : x = ![1, 0] := rfl
      congr
      have h3 : x = ![1, 0] := rfl
      have h4 : x₁ = x2 := by
        calc  x₁ = ![1, 0] := haa
              _ = x2 := by rw [<-ha₂]
      exact h4

lemma continuous_on_union' {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]
  (f : X → Y) (s t : Set X) :
  ContinuousOn f s → ContinuousOn f t → ContinuousOn f (s ∪ t) := by
  intros hcs hct u hu
  have hz0 : u ∉ closure s → ContinuousWithinAt f s u := continuousWithinAt_of_not_mem_closure
  have hz1 : u ∉ closure t → ContinuousWithinAt f t u := continuousWithinAt_of_not_mem_closure

  cases hu with
   | inl hsu => have h1 : ContinuousWithinAt f s u := hcs u hsu
                have h2 : u ∈ closure t ∪ (closure t)ᶜ := sorry
                cases h2 with
                | inl hct => exact ContinuousWithinAt.union h1 sorry
                | inr hctn => exact ContinuousWithinAt.union h1 (hz1 hctn)
   | inr hst => exact sorry

  have h1 : ∀ x ∈ s, ContinuousWithinAt f s x := by
    intro x hx y hy
    exact hcs x hx hy
  have h2 : ∀ x ∈ t, ContinuousWithinAt f t x := by
    intro x hx y hy
    exact hct x hx hy

  have h3a : ContinuousWithinAt f s u := h1 u (by exact hu)

  have h3 : ∀ x, ContinuousWithinAt f (s ∪ t) x := by
    intro x y hy
    have h3a : ContinuousWithinAt f s x := sorry
    have h3b : ContinuousWithinAt f t x := sorry 
    have h3c : ContinuousWithinAt f (s ∪ t) x := ContinuousWithinAt.union h3a h3b
    exact (sorry : y ∈ Filter.map f (𝓝[s ∪ t] x))
 
  exact sorry

let xh := ((⟨x, h⟩ :  Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 ))
    have kkk : y.val = !₂[1, 0] -> y = xh := by
        intro a
        let zh := xh
        have hp : xh = ((⟨x, h⟩ :  Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 )) := rfl
        have hr : x = !₂[1, 0] := rfl
        obtain ⟨x₁, h₁⟩ := y
        obtain ⟨x₂, h₂⟩ := xh
        congr
        have h1 : x₁ = !₂[1, 0] := a
        have hq : x₂ = x := Subtype.coe_injective rfl
        have hq : x₂ = x := sorry
        have h2 : x₂ = !₂[1, 0] :=  by rw [hq, hr]
        have foo : x₁ = x₂ := by rw [h1, ← h2]
        exact foo

    have bar : a1.val = a2.val → a1 = a2
    have foo : y.val = ![1, 0] -> y = xh := by
      intro a
      let zh := ((⟨x, h⟩ :  Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 ))
      obtain ⟨z2, hz2⟩ := zh
      have hz0 : z2 0 = 1 := sorry -- Prove this using the appropriate method
      have hz1 : z2 1 = 0 := sorry -- Prove this using the appropriate method
      congr
      exact a
    have foo : y.val = ![1, 0] -> y = xh := by
      let zh := ((⟨x, h⟩ :  Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 ))
      obtain ⟨z2, hz2⟩ := zh
      have foo : ⟨z2, hz2⟩ = xh := by
        congr
        exact (sorry : z2 = x)

      intro a
      
      let fff : EuclideanSpace ℝ (Fin 2) → (Fin (Nat.succ 1) → ℝ) := λ v i => v i
      let ggg : (Fin (Nat.succ 1) → ℝ) → EuclideanSpace ℝ (Fin 2) := λ h => h

      obtain ⟨x₁, h₁⟩ := y
      have haa : x₁ = ![1, 0] := a
      have h5 : xh = ((⟨x, h⟩ :  Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 )) := rfl
      obtain ⟨x2, hh2⟩ := xh
      have hz0 : x 0 = 1 := rfl
      have hz1 : x 1 = 0 := rfl

      have hy0 : x2 0 = 1 := sorry
      

      have ha₂ : x2 = ![1, 0] := sorry
      have h3 : x = ![1, 0] := rfl
      congr
      have h3 : x = ![1, 0] := rfl
      have h4 : x₁ = x2 := by
        calc  x₁ = ![1, 0] := haa
              _ = x2 := by rw [<-ha₂]

      exact h4


* Log for [2025-03-07 Fri 07:57]


have h3de : y.val 1 = 0 ↔ y.val 0 = 1 ∨ y.val 0 = -1

have foo : y.val = (-xh).val -> y = -xh := Subtype.eq

exact (sorry : y.val 1 = 0 ↔ y = -xh ∨ y = -ug)

have florg : (WithLp.equiv 2 (Fin 2 → ℝ)) (![-a, -b]) = -(WithLp.equiv 2 (Fin 2 → ℝ)) (![a, b]) := by rw [fleeg] at flurg

    have baz4 : !₂[(x 0), (x 1)] = x := urk
    have baz4 : !₂[x 0, x 1] = x := urk
    have baz1 : (-!₂[a, b]) 0 = -a := rfl
    have baz2 : (-!₂[a, b]) 1 = -b := rfl

    have baz3 : !₂[((-!₂[a, b]) 0), ((-!₂[a, b]) 1)] = !₂[-a, -b] := by simp
    let x := (-!₂[a, b])
    have baz4 : !₂[x 0, x 1] = x := urk

  have foo1 : -!₂[a, b] = - (WithLp.equiv 2 ((Fin 2 → ℝ))).symm ![a, b] := rfl
  have foo2 : !₂[-a, -b] = (WithLp.equiv 2 ((Fin 2 → ℝ))).symm ![-a, -b] := rfl
  have baza : (!₂[a, b]) 0 = (!₂[a, b]) 0 := WithLp.equiv_symm_pi_apply 2 (λ i => ℝ) ((![a, b])) (0 : Fin 2)
  have bazb : (!₂[a, b]) 1 = (!₂[a, b]) 1 := WithLp.equiv_symm_pi_apply 2 (λ i => ℝ) ((![a, b])) (1 : Fin 2)
  have baz : (!₂[a, b]) = (!₂[a, b])  := sorry
  -- rw [baz]

  have baz0 : (WithLp.equiv 2 (Fin 2 → ℝ)).symm (!₂[a, b]) 0 = (!₂[a, b]) 0 := WithLp.equiv_symm_pi_apply 2 (λ i => ℝ) ((![a, b])) (0 : Fin 2)
  have baz1 : (WithLp.equiv 2 (Fin 2 → ℝ)).symm (!₂[a, b]) 1 = (!₂[a, b]) 1 := WithLp.equiv_symm_pi_apply 2 (λ i => ℝ) ((![a, b])) (1 : Fin 2)
  have baz : (WithLp.equiv 2 (Fin 2 → ℝ)).symm (!₂[a, b]) = (!₂[a, b]) := sorry
  -- rw [foo1, foo2]
  have bar1 : (((- (!₂[a, b])) 0) : ℝ) = - a := rfl
  have bar2 : (((- (!₂[a, b])) 1) : ℝ) = - b := rfl

  have bar3 : !₂[-a, -b] = !₂[(((- (!₂[a, b])) 0)), (((- (!₂[a, b])) 1))] := rfl


  have bar5 :  - !₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)] = - !₂[a, b] := by simp

  have bar7a : (- !₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)]) 0 = - ((!₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)]) 0) := rfl

  have bar7 : (- !₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)]) = - ((!₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)])) := rfl
  have bar8 :  - ((!₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)])) = - (!₂[a, b]) := by simp



  
  
  have bar3 : !₂[(((- (!₂[a, b])) 0) : ℝ), (((- (!₂[a, b])) 1) : ℝ)] = !₂[- a, - b] := rfl

  have bar4 : !₂[(((- (!₂[a, b])) 0) : ℝ), (((- (!₂[a, b])) 1) : ℝ)] = - !₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)] := sorry
  have bar5 :  - !₂[((((!₂[a, b])) 0) : ℝ), ((((!₂[a, b])) 1) : ℝ)] = - !₂[a, b] := by simp
  exact sorry

  variable {aaa : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1}
variable {bbb : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1}

example (h : aaa.val = bbb.val) : aaa = bbb := by
  obtain ⟨x₁, h₁⟩ := aaa
  obtain ⟨x₂, h₂⟩ := bbb
  congr

 emma urk :
  !₂[(id.comp x) 0 , (id.comp x) 1] = (x.comp neg) := rfl


  lemma eq_of_components (a b : ℝ) : 
  !₂[((!₂[a, b]) 0), ((!₂[a, b]) 1)] = !₂[a, b] :=
by
  simp

* Log for [2025-03-08 Sat 07:26]

      -- have h0 : y.val 1 = 0 := hy1
      -- have h1 : y.val 0 = 1 ∨ y.val 0 = -1 := bar4.mp hy1
      -- have h2 : y.val 0 = 1 ∧ y.val 1 = 0 ∨ y.val 0 = -1 ∧ y.val 1 = 0 := sorry
      -- have h3 : y.val = !₂[1, 0] ∨ y.val = !₂[-1, 0] := sorry
      -- sorry


          -- have ber3 (a b : ℝ) : !₂[((!₂[a, b]) 0), ((!₂[a, b]) 1)] = !₂[a, b] := by simp
    -- have ber4 (x : Fin 2 → ℝ) : x = ![x 0, x 1] := by
    --   ext i
    --   fin_cases i
    --   · simp
    --   · simp
    -- have ber5 (x : EuclideanSpace ℝ (Fin 2)) : x = !₂[x 0, x 1] := by
    --   ext i
    --   fin_cases i
    --   · simp
    --   · simp


          -- exact (sorry : y.val = xh.val ∨ y.val = -xh.val ↔ y = -xh ∨ y = -ug)

have chat1 : y.val 1 = 0 ↔ y = xh ∨ y = ug := by
      rw [bar5]
      constructor
      · intro h
        cases h with
        | inl hxh => left
                     have h : y = xh :=  fooo1 hxh
                     have h1 : y.val = xh.val := by rw [h]
                     have h2 : y.val = -ug.val := by
                      calc y.val = xh.val := h1
                           _ = -ug.val := bar7
                     exact (Subtype.eq h2)
        | inr hug => right; exact fooo2 hug
      · intro h
        cases h with
        | inl hxh => left; rw [← barr1 hxh]
        | inr hug => right; rw [← barr2 hug]


have ha : chart_excluding_minus_1.source ∩ chart_excluding_1.source = { x | x ≠ -xh } ∩ { x | x ≠ -ug } := by rw [h8, h9]

have h1 : { x : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 | x.val 1 > 0 } ∪ { x | x.val 1 < 0 } = { x | x.val 1 = 0 }ᶜ := by

have h2 : { x | x ≠ -xh } ∩ { x | x ≠ -ug } = { -xh, -ug }ᶜ := by

have h3 : { x | x.val 1 = 0 } = { -xh, -ug } := by

have h4 : { x | x.val 1 = 0 }ᶜ = { -xh, -ug }ᶜ := by

have h5 : chart_excluding_minus_1.source ∩ chart_excluding_1.source = { x | x ≠ -xh } ∩ { x | x ≠ -ug } := ha
          _ = { -xh, -ug }ᶜ := h2
	  _ = { x | x.val 1 = 0 }ᶜ := h4
	  _ = { x : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1 | x.val 1 > 0 } ∪ { x | x.val 1 < 0 } := h1


have bar1 : xh.val = !₂[1, 0]  := rfl
have bar2 : ug.val = !₂[-1, 0] := rfl
have bar4 : y.val 1 = 0 ↔ y.val 0 = 1 ∨ y.val 0 = -1 := h3de

have bar5b : y.val = xh.val ∨ y.val = ug.val -> y.val 1 = 0

If y.val = xh.val then y.val 1 = 0
If y.val = ug.val then y.val 1 = 0


-- open scoped BigOperators
-- open Fin

-- variable {𝕜 : Type*} [NormedField 𝕜] {n : ℕ}

-- def LpFin2 := EuclideanSpace 𝕜 (Fin 2)

-- notation " !₂[" x ", " y "]" => (WithLp.equiv 2 _ _).symm ![x, y]
-- def foo := !₂[(1 : ℝ), 0]
-- def bar := (WithLp.equiv 2 ((Fin 2 → ℝ))).symm (![(0 : ℝ), 0])

--   lemma neg_Lp_eq_componentwise_neg (a b : ℝ) :
--     -!₂[a, b] = !₂[-a, -b] :=
--   by

--     let x := ![a, b]
--     let y := ![-a, -b]
--     have fleeg : -(![a, b]) = ![-a, -b] := by simp
--     have flarg : -x = y := by rw [fleeg]

--     have flurg : (WithLp.equiv 2 (Fin 2 → ℝ)) (-x) = -(WithLp.equiv 2 (Fin 2 → ℝ)) x := WithLp.equiv_neg 2 x
--     have flurg : (WithLp.equiv 2 (Fin 2 → ℝ)) (-x) = -(WithLp.equiv 2 (Fin 2 → ℝ)) x := WithLp.equiv_neg 2 x

--     have florg : (WithLp.equiv 2 (Fin 2 → ℝ)) y = -(WithLp.equiv 2 (Fin 2 → ℝ)) x := by rw [flarg] at flurg; exact flurg
--     have flarq : !₂[-a, -b] = -!₂[a, b] := by exact florg
--     exact flarq.symm

* Log for [2025-03-09 Sun 11:49]

instance : Fact (Module.finrank ℝ (EuclideanSpace ℝ (Fin 2)) = 1 + 1) :=
  ⟨(finrank_euclideanSpace_fin : Module.finrank ℝ (EuclideanSpace ℝ (Fin 2)) = 2)⟩

theorem chartAt_source (y : Metric.sphere (0 : EuclideanSpace ℝ (Fin 2)) 1) :
    (chartAt (EuclideanSpace ℝ (Fin 1)) y).source = (stereographic' 1 (-y)).source := rfl

* Log for [2025-03-11 Tue 09:36]

open Complex

def S1 : Type := Submonoid.unitSphere ℂ
deriving TopologicalSpace

theorem exp_mem_unitSphere (r : ℝ) : exp (r * I) ∈ Submonoid.unitSphere ℂ := by
  have h1 : abs (exp (r * I)) = 1 := abs_exp_ofReal_mul_I r
  have h2 : exp (r * I) ∈ Metric.sphere 0 1 ↔ ‖exp (r * I)‖ = 1 := mem_sphere_zero_iff_norm
  have h3 : ‖exp (r * I)‖ = abs (exp (r * I)) := rfl
  have h5 : ‖exp (r * I)‖ = 1 := by
    rw [h3, h1]
  have h6 : exp (r * I) ∈ Metric.sphere 0 1 := h2.2 h5
  have h7 : exp (r * I) ∈ Submonoid.unitSphere ℂ := h6
  exact h7

theorem arg_exp_of_range (r : ℝ) (hr : -Real.pi < r ∧ r < Real.pi) :
  arg (exp (r * I)) = r := by
  have h_in_range : r ∈ Ioo (-Real.pi) Real.pi := hr
  have h_in_range : r ∈ Ioc (-Real.pi) Real.pi := by
    exact Ioo_subset_Ioc_self h_in_range
  have bik : arg (exp (r * I)) = toIocMod (mul_pos two_pos Real.pi_pos) (-Real.pi) r := Complex.arg_exp_mul_I r
  have bil : toIocMod (mul_pos two_pos Real.pi_pos) (-Real.pi) r = r ↔ r ∈ Ioc (-Real.pi) ((-Real.pi) + (2 * Real.pi)) :=
    toIocMod_eq_self (mul_pos two_pos Real.pi_pos)
  have h_eq : -Real.pi + 2 * Real.pi = Real.pi := by ring
  have bin : toIocMod (mul_pos two_pos Real.pi_pos) (-Real.pi) r = r ↔ r ∈ Ioc (-Real.pi) Real.pi := by
    rwa [h_eq] at bil
  have bim : toIocMod (mul_pos two_pos Real.pi_pos) (-Real.pi) r = r := bin.mpr h_in_range
  have crk : arg (exp (r * I)) = r := by rw [bik, bim]
  exact crk

noncomputable
def chart_at_S1_excluding_minus_1 : PartialHomeomorph S1 ℝ :=
{
  toFun := λ z => arg z.val,
  invFun := λ r => ⟨exp (r * Complex.I), exp_mem_unitSphere r⟩,
  source := {z : S1 | arg z.val ∈ Ioo (-Real.pi) (Real.pi)},
  target := Ioo (-Real.pi) (Real.pi),
  map_source' := λ z hz => hz,
  map_target' := λ r hr => by
    have h1 : (exp (r * I)).arg = r := arg_exp_of_range r hr
    have h2a : (-Real.pi) < r := hr.1
    have h2b : r < Real.pi := hr.2
    have h3a : (-Real.pi) < (exp (r * I)).arg := by
      rw [h1]
      exact h2a
    have h3b : (exp (r * I)).arg < (Real.pi) := by
      rw [h1]
      exact h2b
    exact ⟨(h3a : (-Real.pi) < (exp (r * I)).arg), (h3b : (exp (r * I)).arg < (Real.pi))⟩,
  left_inv' := λ z hz => by
    have h0 : (Complex.abs z.val) * exp ((z.val).arg * I) = z.val := by exact abs_mul_exp_arg_mul_I z.val
    have h4 : z.val ∈ Submonoid.unitSphere ℂ := by exact z.prop
    have h5 : z.val ∈ Metric.sphere 0 1 ↔ ‖z.val‖ = 1 := mem_sphere_zero_iff_norm
    have h7 : z.val ∈ Metric.sphere 0 1 := h4
    have h6 : ‖z.val‖ = 1 := by rwa [h5] at h7
    have h8 : ‖z.val‖ * exp ((z.val).arg * I) = z.val := by exact abs_mul_exp_arg_mul_I z.val
    have h9 : z.val = exp ((z.val).arg * I) := by
      calc z.val = ‖z.val‖ * exp ((z.val).arg * I) := by rw [h8]
                _ = (1 : ℝ) *  exp ((z.val).arg * I) := by rw [h6]
                _ = (1 : ℂ) * exp ((z.val).arg * I) := by norm_cast
                _ = exp ((z.val).arg * I) := by rw [one_mul]
    have h3 : (fun r => ⟨exp (r * I), by exact exp_mem_unitSphere r⟩) (z.val).arg = z := by
      apply Subtype.ext
      exact h9.symm
    exact h3
  right_inv' := λ r hr => by
   have h1 : arg (exp (r * I)) = r := arg_exp_of_range r hr
   exact h1
  open_source := by
    exact sorry,
  open_target := isOpen_Ioo,
  continuousOn_toFun  := (sorry : (ContinuousOn (λ z => arg z.val)) {z : S1 | arg z.val ∈ Ioo (-Real.pi) (Real.pi)}),
  continuousOn_invFun := sorry
}

variables (z : S1)

#check z.1
#check z.2

#check ((λ r => ⟨exp (r * Complex.I), exp_mem_unitSphere r⟩) : ℝ → ↥(Submonoid.unitSphere ℂ))
#check Complex.arg_exp_mul_I
#check toIocMod (mul_pos two_pos Real.pi_pos) (-Real.pi) (Real.pi / 4) = (Real.pi / 4)
#check toIocMod (mul_pos two_pos Real.pi_pos) (-Real.pi) (Real.pi / 4) = (Real.pi / 4)
#check toIocMod_eq_self

noncomputable
def chart_at_S1_excluding_1 : PartialHomeomorph S1 ℝ :=
{
  toFun := λ z => arg z.val,
  invFun := λ r => ⟨exp (r * Complex.I), exp_mem_unitSphere r⟩,
  source := {z : S1 | arg z.val ∈ Ioo 0 (2 * Real.pi)},
  target := Ioo 0 (2 * Real.pi),
  map_source' := λ z hz => hz,
  map_target' := λ r hr => ⟨sorry, sorry⟩,
                 -- λ r hr => ⟨exp (r * Complex.I), by simp; exact hr⟩,
  -- left_inv' : ∀ ⦃x⦄, x ∈ source → invFun (toFun x) = x
  -- left_inv' := λ z hz => Subtype.ext (by rw [baz z hz]),
  left_inv' := λ z hz => sorry
  right_inv' := λ r hr => sorry, -- by simp [hr],
  open_source := sorry, -- Needs proof that {z : S1 | arg z.val ∈ Ioo 0 (2 * π)} is open
  open_target := isOpen_Ioo,
  continuousOn_toFun := sorry, -- Needs proof that `arg` is continuous on `source`
  continuousOn_invFun := sorry  -- Needs proof that `exp` is continuous on `target`
}

def source : Set S1 := {z : S1 | arg z.val ∈ Ioo (-Real.pi) Real.pi}

#check ContinuousAt arg

noncomputable
def joo : GBundleCore (atlas (EuclideanSpace ℝ (Fin 1)) Circle) Circle (Fin 1 -> ℝ) (orthogonalGroup (Fin 1) ℝ) where
  baseSet i := i.1.source
  isOpen_baseSet i := i.1.open_source
  indexAt := achart (EuclideanSpace ℝ (Fin 1))
  mem_baseSet_at := mem_chart_source (EuclideanSpace ℝ (Fin 1))
  coordChange i j x v := v
  coordChange_self _ _ _ _ := rfl
  continuousOn_coordChange i j := continuous_snd.continuousOn
  coordChange_comp _ _ _ _ _ _ := rfl
  coordChange_structure_group := by sorry


  coordChange_structure_group i j := by
    intro x hx
    have h0 : x ∈ (fun i ↦ if i = 0 then U.source else V.source) i ∩ (fun i ↦ if i = 0 then U.source else V.source) j := hx
    fin_cases i
    · fin_cases j
      . have h11 : x ∈ U.source := by
          simp only [ite_true, if_pos rfl, inter_self] at h0
          exact h0
        have h1 : ∃ g : (orthogonalGroup (Fin 1) ℝ), ∀ v : (EuclideanSpace ℝ (Fin 1)), v = g • v := by
            existsi 1
            intro v
            have h2 : (1 : (orthogonalGroup (Fin 1) ℝ)) • v = v := one_smul (orthogonalGroup (Fin 1) ℝ) v
            exact h2.symm
        exact h1
      · have h12 : x ∈ U.source ∩ V.source := by
          simp only [ite_true, if_pos rfl, inter_self] at h0
          exact h0
        have h1 : ∃ g : (orthogonalGroup (Fin 1) ℝ), ∀ v : (EuclideanSpace ℝ (Fin 1)), v = g • v := by
            existsi 1
            intro v
            have h2 : (1 : (orthogonalGroup (Fin 1) ℝ)) • v = v := one_smul (orthogonalGroup (Fin 1) ℝ) v
            exact h2.symm
        have h2 : ∃ (g : ↥(orthogonalGroup (Fin 1) ℝ)), ∀ (v : EuclideanSpace ℝ (Fin 1)), MyCoordChange ((fun i ↦ i) 0) ((fun i ↦ i) 1) x v = g • v := sorry
        exact h2
    · fin_cases j
      · exact sorry
      · exact sorry

noncomputable
def joo : GBundleCore (atlas (EuclideanSpace ℝ (Fin 1)) Circle) Circle (Fin 1 -> ℝ) (orthogonalGroup (Fin 1) ℝ) where
  baseSet i := i.1.source
  isOpen_baseSet i := i.1.open_source
  indexAt := achart (EuclideanSpace ℝ (Fin 1))
  mem_baseSet_at := mem_chart_source (EuclideanSpace ℝ (Fin 1))
  coordChange i j x v := v
  coordChange_self _ _ _ _ := rfl
  continuousOn_coordChange i j := continuous_snd.continuousOn
  coordChange_comp _ _ _ _ _ _ := rfl
  coordChange_structure_group := by sorry


example (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : ℝ) :
  !![a₁₁, a₁₂;
     a₂₁, a₂₂] * !![b₁₁, b₁₂;
                    b₂₁, b₂₂] =
  !![a₁₁*b₁₁ + a₁₂*b₂₁, a₁₁*b₁₂ + a₁₂*b₂₂;
     a₂₁*b₁₁ + a₂₂*b₂₁, a₂₁*b₁₂ + a₂₂*b₂₂] :=
(mulᵣ_eq _ _).symm

example [AddCommMonoid α] [Mul α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α) :
  !![a₁₁, a₁₂;
     a₂₁, a₂₂] * !![b₁₁, b₁₂;
                    b₂₁, b₂₂] =
  !![a₁₁*b₁₁ + a₁₂*b₂₁, a₁₁*b₁₂ + a₁₂*b₂₂;
     a₂₁*b₁₁ + a₂₂*b₂₁, a₂₁*b₁₂ + a₂₂*b₂₂] :=
(mulᵣ_eq _ _).symm

#check Matrix.mem_orthogonalGroup_iff (Fin 1) ℝ

variable {𝕜 : Type*} [Field 𝕜] {n : Type*} [Fintype n] [DecidableEq n]

example (M : Matrix (Fin 2) (Fin 2) ℝ) :
  M ∈ Matrix.orthogonalGroup (Fin 2) ℝ ↔ M * star M = 1 := Matrix.mem_orthogonalGroup_iff (Fin 2) ℝ

example (M : Matrix (Fin 1) (Fin 1) ℝ) :
  M ∈ Matrix.orthogonalGroup (Fin 1) ℝ ↔ M * star M = 1 := Matrix.mem_orthogonalGroup_iff (Fin 1) ℝ

example (M : Matrix (Fin 1) (Fin 1) ℝ) : true := by
  have h1 : M * star M = 1 <-> M 0 0 * M 0 0 = 1 := by
    exact sorry
  have h3 : (M * star M) 0 0 = ∑ j : Fin 1, M 0 j * (star M) j 0 := mul_apply
  have h4 : star M = Mᴴ := star_eq_conjTranspose M
  trivial

example (a₁₁ b₁₁ : ℝ) :
  !![a₁₁] * !![b₁₁] = !![a₁₁*b₁₁] := (mulᵣ_eq _ _).symm

example (M : Matrix (Fin 1) (Fin 1) ℝ) :
  M ∈ Matrix.orthogonalGroup (Fin 1) ℝ ↔ M * star M = 1 := Matrix.mem_orthogonalGroup_iff (Fin 1) ℝ

#check etaExpand

example (A : Matrix (Fin 2) (Fin 2) ℝ) : !![A 0 0, A 0 1;  A 1 0, A 1 1] = A := etaExpand_eq A

example (A : Matrix (Fin 1) (Fin 1) ℝ) : !![A 0 0] = A := etaExpand_eq A

example (A : Matrix (Fin 1) (Fin 1) ℝ) : !![1] = (1 : Matrix (Fin 1) (Fin 1) ℝ):= etaExpand_eq 1

#check NoZeroDivisors

#check Zero

#check SpecialLinearGroup
#check GeneralLinearGroup

#synth NoZeroDivisors (GeneralLinearGroup (Fin 2) ℝ)


example (a : ℝ) :
  !![a] * (star !![a]) = !![a*a] := (mulᵣ_eq _ _).symm

#check ((x ∈ orthogonalGroup (Fin 1) ℝ ↔ x * star x = (1 : orthogonalGroup (Fin 1) ℝ).1) Matrix.mem_orthogonalGroup_iff (Fin 1) ℝ)

example (x : (orthogonalGroup (Fin 1) ℝ)) : x = 1 ∨ x = -1 := by
  have h1 : x ∈ (orthogonalGroup (Fin 1) ℝ) <-> x * star x = 1 := Matrix.mem_orthogonalGroup_iff (Fin 1) ℝ
  exact sorry

variable {v : (EuclideanSpace ℝ (Fin 1))}

example : (1 : (orthogonalGroup (Fin 1) ℝ)) • v = v := by
  have h1 : (1 : orthogonalGroup (Fin 1) ℝ).1.mulVec v = v := by
      simp [Matrix.mulVec_one]
  exact h1

example : (1 : (orthogonalGroup (Fin 1) ℝ)) • v = v := one_smul (orthogonalGroup (Fin 1) ℝ) v


-(1 • v) = -1 • v

-1 • 1 • v = (-1 * 1) • v = -1 • v

      · have h12 : x ∈ U.source ∩ V.source := by
          simp only [ite_true, if_pos rfl, inter_self] at h0
          exact h0

lemma orthGroup1 (a : ℝ) : !![a] ∈ Matrix.orthogonalGroup (Fin 1) ℝ <-> a = 1 ∨ a = -1 := by
  have h1 : !![a] ∈ Matrix.orthogonalGroup (Fin 1) ℝ ↔ !![a] * star !![a] = 1 := Matrix.mem_orthogonalGroup_iff (Fin 1) ℝ
  have h2 : !![a] ∈ Matrix.orthogonalGroup (Fin 1) ℝ <-> !![a * a] = 1 := by
    rw [(mulᵣ_eq _ _).symm] at h1
    exact h1
  have h3 : !![1] = (1 : Matrix (Fin 1) (Fin 1) ℝ) := etaExpand_eq 1
  have h4 : !![a] ∈ Matrix.orthogonalGroup (Fin 1) ℝ <-> !![a * a] = !![1] := by
    rw [h3.symm] at h2
    exact h2
  have h5 : !![a * a] = !![1] ↔ a * a = 1 := by
    apply Iff.intro
    · intro h
      have := Matrix.ext_iff.mpr h 0 0
      exact this
    · intro h
      apply Matrix.ext
      intros i j
      fin_cases i; fin_cases j
      exact h
  have he : !![a] ∈ orthogonalGroup (Fin 1) ℝ ↔ a * a = 1 := Iff.trans h4 h5
  have hd : a * a = 1 ↔ a = 1 ∨ a = -1 := mul_self_eq_one_iff
  have hf : !![a] ∈ orthogonalGroup (Fin 1) ℝ ↔ a = 1 ∨ a = -1 := Iff.trans he hd
  exact hf

lemma orthGroup1' {m} : m ∈ Matrix.orthogonalGroup (Fin 1) ℝ <-> m = 1 ∨ m = -1 := sorry

