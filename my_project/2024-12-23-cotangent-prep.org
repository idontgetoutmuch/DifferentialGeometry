* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

Suppose we have smooth \(f : M \longrightarrow \mathbb{R}\). Then we can
define the derivative of \(f\) to be \(0\) at a point \(a\) if for a
chart \(\phi_\alpha\) then \(D(f \phi_\alpha^{-1}) = 0\). But this may
not be well-defined. Suppose \(\phi_\beta\) is another chart, setting
\(g \triangleq f \phi_\alpha^{-1}\) and
\(g \triangleq f \phi_\beta^{-1}\) then

\[
g=f \phi_\alpha^{-1}=f \phi_\beta^{-1} \phi_\beta \phi_\alpha^{-1}=h \phi_\beta \phi_\alpha^{-1}
\]

and now we are in the familiar world of calculus on \(\mathbb{R}^n\).

On one definition of an atlas, \(\phi_\beta \phi_\alpha^{-1}\) is smooth
with a smooth inverse. By the chain rule for calculus we have

\[
\frac{\partial g}{\partial x_i}=\sum_j \frac{\partial h}{\partial y_j}(y(x)) \frac{\partial y_j}{\partial x_i}(x)
\]

\(\frac{\partial y_j}{\partial x_i}(x)\) has full rank so we can conclude that

\[
D(f\phi_\alpha^{-1}) = 0 \iff D(f\phi_\beta) = 0
\]

* Transition Maps are Smooth
:PROPERTIES:
:CUSTOM_ID: transition-maps-are-smooth
:END:

Mathlib has its own way of defining manifolds which I won't elaborate
here but this does not use the fact that transition maps are smooth
with a smooth inverse.

Even before that we want the fact that two functions have the same
derivative at a point if they agree on an open set containing that
point.

#+begin_src lean4
import Mathlib.Geometry.Manifold.MFDeriv.Defs
import Mathlib.Geometry.Manifold.Instances.Real
import Mathlib.Analysis.InnerProductSpace.PiL2
import Mathlib.Geometry.Manifold.AnalyticManifold
import Mathlib.Geometry.Manifold.ContMDiff.Atlas
import Mathlib.Geometry.Manifold.MFDeriv.SpecificFunctions

open Manifold

open SmoothManifoldWithCorners

theorem mfderivWithin_congr_of_eq_on_open
  {m n : â„•} {M N : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace â„ (Fin m)) M]
  [SmoothManifoldWithCorners (ğ“¡ m) M]
  [TopologicalSpace N]
  [ChartedSpace (EuclideanSpace â„ (Fin n)) N]
  [SmoothManifoldWithCorners (ğ“¡ n) N]
  (f g : M â†’ N) (s : Set M)
  (ho : IsOpen s)
  (he : âˆ€ x âˆˆ s, f x = g x) :
  âˆ€ x âˆˆ s, mfderivWithin (ğ“¡ m) (ğ“¡ n) f s x = mfderivWithin (ğ“¡ m) (ğ“¡ n) g s x := by
    intros x hy
    exact mfderivWithin_congr (IsOpen.uniqueMDiffWithinAt ho hy) he (he x hy)
#+end_src

This is the same as writing a term but the tactics above seem to be
preferred and we will stick to lean traditions from now on bearing in
mind that they can always be re-written as term (well they are a term
really).

#+begin_src lean4
theorem mfderivWithin_congr_of_eq_on_open_as_term
  {m n : â„•} {M N : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace â„ (Fin m)) M]
  [SmoothManifoldWithCorners (ğ“¡ m) M]
  [TopologicalSpace N]
  [ChartedSpace (EuclideanSpace â„ (Fin n)) N]
  [SmoothManifoldWithCorners (ğ“¡ n) N]
  (f g : M â†’ N) (s : Set M)
  (ho : IsOpen s)
  (he : âˆ€ x âˆˆ s, f x = g x) :
  âˆ€ x âˆˆ s, mfderivWithin (ğ“¡ m) (ğ“¡ n) f s x = mfderivWithin (ğ“¡ m) (ğ“¡ n) g s x :=
  Î» z hz =>
    mfderivWithin_congr (IsOpen.uniqueMDiffWithinAt ho hz) he (he z hz)
#+end_src

And now we can state and prove that the transition maps are smooth and
have a smooth inverse.

#+begin_src lean4
theorem contMDiffAt_chart_transition
  (m : â„•) {M : Type*}
  [TopologicalSpace M]
  [ChartedSpace (EuclideanSpace â„ (Fin m)) M]
  [SmoothManifoldWithCorners (ğ“¡ m) M]
  (Ï†_Î± : PartialHomeomorph M (EuclideanSpace â„ (Fin m)))
  (hÎ¦_Î‘ : Ï†_Î± âˆˆ maximalAtlas (ğ“¡ m) M)
  (Ï†_Î² : PartialHomeomorph M (EuclideanSpace â„ (Fin m)))
  (hÎ¦_Î’ : Ï†_Î² âˆˆ maximalAtlas (ğ“¡ m) M)
  (x : M)  (hx : x âˆˆ  Ï†_Î±.source âˆ© Ï†_Î².source) :
   ContMDiffAt (ğ“¡ m) (ğ“¡ m) âŠ¤ (Ï†_Î±.symm.trans Ï†_Î²) (Ï†_Î± x) := by
    have h1 : (Ï†_Î±.symm.trans Ï†_Î²) = Ï†_Î² âˆ˜ Ï†_Î±.symm :=
      PartialHomeomorph.coe_trans Ï†_Î±.symm Ï†_Î²
    have h2 : ContMDiffAt (ğ“¡ m) (ğ“¡ m) âŠ¤ Ï†_Î² x :=
      contMDiffAt_of_mem_maximalAtlas hÎ¦_Î’ hx.2
    have h3 : ContMDiffAt (ğ“¡ m) (ğ“¡ m) âŠ¤ Ï†_Î±.symm (Ï†_Î± x) :=
      contMDiffAt_symm_of_mem_maximalAtlas hÎ¦_Î‘ (PartialHomeomorph.map_source Ï†_Î± hx.1)
    have h4 : Ï†_Î±.symm (Ï†_Î± x) = x := PartialHomeomorph.left_inv Ï†_Î± hx.1
    have h5 : ContMDiffAt (ğ“¡ m) (ğ“¡ m) âŠ¤ Ï†_Î² (Ï†_Î±.symm (Ï†_Î± x)) := by
      rw [h4]
      exact h2
    have h7 : ContMDiffAt (ğ“¡ m) (ğ“¡ m) âŠ¤ (Ï†_Î² âˆ˜ Ï†_Î±.symm) (Ï†_Î± x) :=
      ContMDiffAt.comp (I' := ğ“¡ m) (Ï†_Î± x) h5 h3
    have h8 : ContMDiffAt (ğ“¡ m) (ğ“¡ m) âŠ¤ (Ï†_Î±.symm.trans Ï†_Î²) (Ï†_Î± x) := by
      rw [h1]
      exact h7
    exact h8
#+end_src
